/**
\page cross_blinky Blinky
\image html rkh_bunner.jpg

\n
Prev: \ref cross "Cross-platform examples"\n\n

The goal of "Blinky" demo application is to explain how to represent a "flat" 
state machine, how to use the timer services, and trace facility from RKH 
framework. To do that is proposed a very simple demo that use one state 
machine and one timer, which is shown and itself explained in the 
\ref blinky_fig1 "Blink a LED state diagram". This is the 'hello world' of 
RKH programming. 

The platform-independent Blinky source code (in C) is located in the 
\c \<rkh\>\\demo\\cross\\blinky\\ directory, where \c \<rkh\> stands for the 
installation directory chosed to install the accompanying software and 
\c bky.c, \c bky.h, \c bkyact.c, \c bkyact.h, and \c main.c are the 
platform-independent files. Thus, the code is actually identical in all 
Blinky versions, such as the Windows version, Linux version, arm-cortex 
version, and so on.

- \ref blinky_sm
- \ref blinky_ao
- \ref blinky_init
- \ref blinky_run

<HR>
\section blinky_sm State machine

The following figure shows the state machine associated with Blinky 
active object, which clearly shows the life cycle consisting of states 
\c "led_on", and \c "led_off".

\anchor blinky_fig1
\image html rkh_blinky.png "Blinky state machine"

\li ( 1) 	The \c blinky_init() function defines the topmost initial 
			transition in the my state machine. The function prototype is 
			defined as RKHINIT_T. This argument is (optional), thus it could 
			be declared as NULL. 
\li ( 2) 	The timer \c bkytim is declared with the RKH_TMR_T data type 
			and is defined with the rkh_tim_init() RKH service. The timer is 
			initialized in a non-active state (stopped). In this case, a 
			subsequent start service call is necessary to get the timer 
			actually started.
\li ( 3) 	Turn on the LED and trigger the \c bkytim timer as oneshot to 
			expire in \c LED_ON_TIME milliseconds.
\li ( 4-8) 	Upon receiving the TIMEOUT event, the Blinky re-trigger the 
			\c bkytim timer to expire in \c LED_OFF_TIME milliseconds, turn 
			off the LED, and increments the counter.	
\li ( 9-10)	Turn off the LED and trigger the \c bkytim timer as oneshot to 
			expire in \c LED_OFF_TIME milliseconds.

\note
The notation of UML Statecharts is not purely visual. Any nontrivial state 
machine requires a large amount of textual information (e.g., the 
specification of actions and guards). The exact syntax of action and guard 
expressions isnt defined in the UML specification, so many people use 
either structured English or, more formally, expressions in an implementation 
language such as C [Douglass]. In practice, this means that UML Statechart 
notation depends heavily on the specific programming language.

The \ref bky_c "bky.c" file implements the state machine of Blinky active 
object, which illustrates some aspects of implementing state machines with 
RKH framework. Please correlate this implementation with the state diagram 
shown above. On the other hand, the header file \ref bky_h "bky.h" contains 
the definitions of object structures related to the state machine. \n \n

\anchor bky_c 
<STRONG> \"bky.c\" - State machine representation </STRONG>
\code
#include "rkh.h"


/*
 *	Include file of HSM definitions.
 */

#include "bky.h"


/*
 *	Include file of action/guard definitions
 */

#include "bkyact.h"


/*
 *	Defines SMA (active object) 'blinky'.
 */

RKH_SMA_CREATE( BKYSM_T, blinky, 0, HCAL, &led_on, blinky_init, NULL );


/* Defines the "led_on" state */
RKH_CREATE_BASIC_STATE( led_on, NULL, NULL, RKH_ROOT, NULL );

/* led_on's state transition table */
RKH_CREATE_TRANS_TABLE( led_on )
	RKH_TRREG( TIMEOUT, NULL, 	blinky_led_off,		&led_off ),
RKH_END_TRANS_TABLE

/* Defines the "led_off" state */
RKH_CREATE_BASIC_STATE( led_off, NULL, NULL, RKH_ROOT, NULL );

/* led_off's state transition table */
RKH_CREATE_TRANS_TABLE( led_off )
	RKH_TRREG( TIMEOUT,	NULL,	blinky_led_on,		&led_on ),
RKH_END_TRANS_TABLE
\endcode

\n The related actions (entry, exit, guard, and state transition) to be 
executed by the state machine are implemented and declared in the 
\ref bkyact_c "bkyact.c" and \ref bkyact_h "bkyact.h" file, respectively. 
Note that the \c rkhcfg.h file defines the prototypes of them. \n \n

\anchor bkyact_c 
<STRONG> \"bkyact.c\" - Actions </STRONG>
\code
#include "rkh.h"
#include "bky.h"
#include "bkyact.h"
#include "bsp.h"


#define CBKY( sm_ )		(( BKYSM_T* )(sm_))


/*
 * 	Declare and allocate the 'e_tout' event.
 * 	The 'e_tout' event with TIMEOUT signal never changes, so it can be 
 * 	statically allocated just once by means of RKH_DCLR_STATIC_EVENT() macro.
 */

static RKH_DCLR_STATIC_EVENT( e_tout, TIMEOUT );


/*
 * 	Declare and allocate the 'blktim' timer, which is responsible for 
 * 	toggling the LED posting the TIMEOUT signal event to active object 
 * 	'blinky'.
 */

RKH_TMR_T bkytim;


/*
 *	Defines HSM init function
 */

void 
blinky_init( const struct rkhsma_t *sma )
{
	rkh_tim_init( &bkytim, &e_tout, NULL );
	blinky_led_on( sma, NULL  );	
}


/*
 *	Defines transition action functions
 */

void
blinky_led_on( const struct rkhsma_t *sma, RKH_EVT_T *pe )
{
	(void)pe;

	rkh_tim_oneshot( &bkytim, blinky, LED_ON_TIME );
	bsp_led_on();
	++CBKY(sma)->cnt;
}


void
blinky_led_off( const struct rkhsma_t *sma, RKH_EVT_T *pe )
{
	(void)sma;
	(void)pe;

	rkh_tim_oneshot( &bkytim, blinky, LED_OFF_TIME );
	bsp_led_off();
}
\endcode

\anchor bkyact_h 
\n <STRONG> \"bkyact.h\" - Action declarations </STRONG>
\code
#ifndef __BKYACT_H__
#define __BKYACT_H__


#include "rkh.h"


/*
 *	Defines HSM init function
 */

void blinky_init( const struct rkhsma_t *sma );


/*
 *	Defines transition action functions
 */

void blinky_led_on( const struct rkhsma_t *sma, RKH_EVT_T *pe );
void blinky_led_off( const struct rkhsma_t *sma, RKH_EVT_T *pe );


#endif
\endcode

<HR>
\section blinky_ao Signals, events, and active objects

\n In RKH, signals are typically enumerated constants and events with 
parameters are structures derived from the RKH_EVT_T base structure. The next 
listing shows signals and events used in the Blinky application 
(\ref bky_h "bky.h"). \n \n

\anchor bky_h 
<STRONG> \"bky.h\" - Signals, events, and active objects </STRONG>
\code
#ifndef __BKY_H__
#define __BKY_H__


#include "rkh.h"


#define LED_OFF_TIME			RKH_TIME_SEC( 2 )
#define LED_ON_TIME				RKH_TIME_SEC( 2 )


/*
 * 	Signals.
 */

enum
{
	TIMEOUT,		/* 'blktim' timeout */
	TERMINATE,		/* press the key escape on the keyboard */
	BKY_NUM_EVENTS
};


typedef struct
{
	RKH_SMA_T sma;	/* base structure */
	rkhui8_t cnt;	/* private member */
} BKYSM_T;			/* SMA derived from RKH_SMA_T structure */


/*
 *	Declare HSM.
 */

RKH_SMA_DCLR( blinky );


/*
 *	Declare states and pseudostates.
 */

RKH_DCLR_BASIC_STATE	led_off, led_on;


#endif
\endcode

\n <HR>
\section blinky_init Initializing and starting the application

Most of the system initialization and application startup can be written 
in a platform-independent way. \n

<STRONG> \"main.c\" - main() function </STRONG>
\code
#include "rkh.h"
#include "rkhtrc.h"
#include "bsp.h"
#include "svr.h"
#include "svract.h"
#include "cli.h"
#include "cliact.h"


#define QSTO_SIZE			4

static RKH_EVT_T *svr_qsto[ QSTO_SIZE ];
static RKH_EVT_T *cli_qsto[ NUM_CLIENTS ][ QSTO_SIZE ];


int
main( int argc, char *argv[] )
{
	HInt cn;

	/* invoke the rkh_init() function */
	bsp_init( argc, argv );

	/* send objects to trazer */
	RKH_TR_FWK_AO( svr );
	RKH_TR_FWK_AO( CLI0 );
	RKH_TR_FWK_AO( CLI1 );
	RKH_TR_FWK_AO( CLI2 );
	RKH_TR_FWK_AO( CLI3 );
	RKH_TR_FWK_STATE( svr, &svr_idle );
	RKH_TR_FWK_STATE( svr, &svr_busy );
	RKH_TR_FWK_STATE( svr, &svr_paused );
	RKH_TR_FWK_STATE( CLI0, &cli_idle );
	RKH_TR_FWK_STATE( CLI0, &cli_waiting );
	RKH_TR_FWK_STATE( CLI0, &cli_using );
	RKH_TR_FWK_STATE( CLI0, &cli_paused );

	/* send signals to trazer */
	RKH_TR_FWK_SIG( REQ );
	RKH_TR_FWK_SIG( START );
	RKH_TR_FWK_SIG( DONE );
	RKH_TR_FWK_SIG( TOUT_USING );
	RKH_TR_FWK_SIG( TOUT_REQ );
	RKH_TR_FWK_SIG( PAUSE );
	RKH_TR_FWK_SIG( TERM );

	rkh_sma_activate( svr, (const RKH_EVT_T **)svr_qsto, QSTO_SIZE, 
																CV(0), 0 );
	for( cn = 0; cn < NUM_CLIENTS; ++cn )
		rkh_sma_activate( CLI(cn), (const RKH_EVT_T **)cli_qsto[cn], 
												QSTO_SIZE, CV(0), 0 );
	rkh_enter();

	RKH_TRC_CLOSE();
	return 0;
}
\endcode

\n <HR>
\section blinky_run Running on various platforms

As said before, the only platform-dependent file is the board support package 
(BSP) definition. Each of supported platforms defines its own \c bsp.c and 
\c bsp.h files, which are contained in the proper directory, for example, the 
BSP for the Blinky application on Windows 32 (Visual Studio 2008) with a 
simple cooperative scheduler is located in 
\c \<rkh\>\\demo\\cross\\blinky\\platform\\80x86\\win32_st\\vc08\\

<TABLE	align="center" valign="middle" width=70% cellSpacing=2 
		cellPadding=4 border=0>

	<TR bgColor="#c0c0c0">
		<TH><B> CPU Architecture </B></TH>
		<TH><B> Manufacturer </B></TH>
		<TH><B> MCU </B></TH>
		<TH><B> Evaluation Board </B></TH> 
		<TH><B> Toolchain </B></TH> 
		<TH><B> Comments </B></TH> 
		<TH><B> Notes </B></TH> 
	</TR>

	<TR bgColor="#f0f0f0" align="center" valign="middle" >
		<TD rowspan="4"> ARM - Cortex </TD>
		<TD> NXP </TD>
		<TD> <A HREF="http://www.nxp.com/products/microcontrollers/cortex_m3/
		LPC1769FBD100.html">LPC1769</A> </TD>
		<TD> <A HREF="http://www.embeddedartists.com/products/lpcxpresso/
		lpc1769_xpr.php">LPCXpresso</A> </TD>
		<TD> Codered </TD>
		<TD> Native cooperative scheduler </TD>
		<TD> \ref cross_lpcx1769 "readme" </TD>
	</TR>

	<TR bgColor="#f0f0f0" align="center" valign="middle" >
		<TD> Freescale </TD>
		<TD> <A HREF="http://www.freescale.com/webapp/sps/site/
		taxonomy.jsp?code=K60_ETHERNET_CRYPTO_MCU&
		tid=mKOvp">Kinetis K60</A> </TD>
		<TD> <A HREF="http://www.freescale.com/webapp/sps/site/
		prod_summary.jsp?code=TWR-K60D100M">TWR-K60D100M</A> </TD>
		<TD> Codewarrior v10.x </TD>
		<TD> Native cooperative scheduler </TD>
		<TD> \ref cross_twr_K60 "readme" </TD>
	</TR>

	<TR bgColor="#f0f0f0" align="center" valign="middle" >
		<TD> Freescale </TD>
		<TD> <A HREF="http://www.freescale.com/webapp/sps/site/
		prod_summary.jsp?code=KL2">Kinetis KL2</A> </TD>
		<TD> <A HREF="http://www.freescale.com/webapp/sps/site/
		prod_summary.jsp?code=FRDM-KL25Z">FRDM-KL25Z</A> </TD>
		<TD> Codewarrior v10.x </TD>
		<TD> Native cooperative scheduler </TD>
		<TD> \ref cross_frdm_kl25 "readme" </TD>
	</TR>

	<TR bgColor="#f0f0f0" align="center" valign="middle" >
		<TD> Freescale </TD>
		<TD> <A HREF="http://www.freescale.com/webapp/sps/site/
		prod_summary.jsp?code=
		K40_100&nodeId=01624698C9DE2DDDAB">Kinetis K40</A> </TD>
		<TD> <A HREF="https://www.freescale.com/webapp/sps/site/
		prod_summary.jsp?code=KWIKSTIK-K40">KWIKSTIK-K40</A> </TD>
		<TD> Codewarrior v10.x </TD>
		<TD> Native cooperative scheduler </TD>
		<TD> \ref cross_kwi_K40 "readme" </TD>
	</TR>

	<TR bgColor="#c8cedc" align="center" valign="middle" >
		<TD> Freescale </TD>
		<TD> Coldfire V1 </TD>
		<TD> <A HREF="http://www.freescale.com/webapp/sps/site/
		prod_summary.jsp?code=MCF51QE">MCF51QE128</A> </TD>
		<TD> <A HREF="http://www.freescale.com/webapp/sps/site/
		prod_summary.jsp?code=DEMOQE128">DEMOQE128</A> </TD>
		<TD> Codewarrior v6.x </TD>
		<TD> Native cooperative scheduler </TD>
		<TD> \ref cross_demoqe128_cfv1 "readme" </TD>
	</TR>

	<TR bgColor="#f0f0f0" align="center" valign="middle" >
		<TD> Freescale </TD>
		<TD> S08 </TD>
		<TD> <A HREF="http://www.freescale.com/webapp/sps/
		site/prod_summary.jsp?code=S08QE">S08QE128</A> </TD>
		<TD> <A HREF="http://www.freescale.com/webapp/sps/site/
		prod_summary.jsp?code=DEMOQE128">DEMOQE128</A> </TD>
		<TD> Codewarrior v6.x </TD>
		<TD> Native cooperative scheduler </TD>
		<TD> \ref cross_demoqe128_s08 "readme" </TD>
	</TR>

	<TR bgColor="#c8cedc" align="center" valign="middle" >
		<TD rowspan="2"> 80x86 </TD>
		<TD> --- </TD>
		<TD> --- </TD>
		<TD> --- </TD>
		<TD> <A HREF="http://www.microsoft.com/en-us/download/
		details.aspx?id=5555">Visual Studio C++ 2010 </A> </TD>
		<TD> Win32 cooperative scheduler simulation </TD>
		<TD>  </TD>
	</TR>

	<TR bgColor="#c8cedc" align="center" valign="middle">
		<TD> --- </TD>
		<TD> --- </TD>
		<TD> --- </TD>
		<TD> GNU </TD>
		<TD> Linux cooperative scheduler simulation </TD>
		<TD>  </TD>
	</TR>
</TABLE>

Prev: \ref cross "Cross-platform examples"\n
*/


/**
\page cross_shared Shared
\image html rkh_bunner.jpg

\n
Prev: \ref cross "Cross-platform examples"\n\n

This application deals with the shared resource problem in active object 
systems. Showing one of the biggest benefit of using active objects: resource 
encapsulation. The encapsulation naturally designates the owner of the 
resource as the ultimate arbiter in resolving any contention and potential 
conflicts for the resource. The shared application is relatively simple and 
can be tested only with a couple of LEDs on your target board.
Still, Shared contains five (5) concurrent active objects that exchange 
events via direct event posting mechanism. The application uses four timers, 
as well as dynamic and static events. On the other hand, this application 
could be used in either preemptive or cooperative enviroment.
Aditionally, the Shared could be used to verify a new RKH port.

The platform-independent Shared source code (in C) is located in the 
\c \<rkh\>\\demo\\cross\\shared\\ directory, where \c \<rkh\> stands for the 
installation directory chosed to install the accompanying software and 
\c svr.c, \c svr.h, \c svract.c, \c svract.h, \c cli.c, \c cli.h, 
\c cliact.c, \c cliact.h,\c scevt.h and \c main.c are the 
platform-independent files. Thus, the code is actually identical in all 
Shared versions, such as the Windows version, S08 version, and so on.

- \ref shared_sd
- \ref shared_sm
- \ref shared_ao
- \ref shared_init
- \ref shared_run

<HR>
\section shared_sd Sequence diagram

The sequence diagram in \ref shared_sd_fig1 "Figure 1" shows the most 
representative event exchanges among three Clients (cli0, cli1, cli2) and the 
Server (svr) active objects.

The server shares their resource with clients. A client does not share any of 
its resources, but requests a server's content or service function. Clients 
therefore initiate communication sessions with the server which await incoming 
requests.
The server selectively shares its resource; and a client initiates contact 
with the server in order to make use of the resource.
Clients and server exchange messages in a request-response messaging pattern: 
The client sends a request, and the server returns a response.

As an additional feature, the Clients  can be paused for an arbitrary period 
of time. During this paused period, the Clients don't get permissions to 
request. After the pause period, the Clients should resume normal operation.

\anchor shared_sd_fig1
\image html rkh_shared_sd.png "Figure 1 - Sequence diagram of the Shared application"

<HR>
\section shared_sm State machines

Figure 2(a) shows the state machine associated with Client active object, 
which clearly shows the life cycle consisting of states \c "cli_idle", \c "svr_paused", 
\c "svr_waiting", and \c "cli_using". See \ref shared_sm_cli section.

\anchor shared_svr_fig2a
\image html rkh_shared_svr.png "Figure 2(a) - Server (svr) state machine"

Figure 2(b) shows the state machine associated with the Server active object, 
with  \c "svr_idle", \c "svr_paused", and \c "svr_busy" states. See 
\ref shared_sm_svr section.

\anchor shared_cli_fig2b
\image html rkh_shared_cli.png "Figure 2b - Client (cli) state machine"

\note
The notation of UML Statecharts is not purely visual. Any nontrivial state 
machine requires a large amount of textual information (e.g., the 
specification of actions and guards). The exact syntax of action and guard 
expressions isnt defined in the UML specification, so many people use 
either structured English or, more formally, expressions in an implementation 
language such as C [Douglass]. In practice, this means that UML Statechart 
notation depends heavily on the specific programming language.

\subsection shared_sm_cli Client state-machine implementation

The \ref cli_c "cli.c" file implements the state machine of Server active 
object, which illustrates some aspects of implementing state machines with 
RKH framework. Please correlate this implementation with the state diagram 
shown above. On the other hand, the header file \ref cli_h "cli.h" contains 
the definitions of object structures related to the state machine. 
See the following sections:

- \ref cli_c "Client state machine representation - \"cli.c\""
- \ref cliact_c "Client actions - \"cliact.c\""
- \ref cliact_h "Client action declarations - \"cliact.h\""

\n \n
\anchor cli_c 
<STRONG> \"cli.c\" - Client state machine representation </STRONG> \n
\code
#include "rkh.h"


/*
 *	Include file of HSM definitions.
 */

#include "cli.h"


/*
 *	Include file of action/guard definitions
 */

#include "cliact.h"


/*
 *	Defines SMA (a.k.a Active Object) "cli".
 */

RKH_SMA_CREATE( CLI_T, cli0, CLI_PRIO_0, HCAL, &cli_idle, cli_init, NULL );
RKH_SMA_CREATE( CLI_T, cli1, CLI_PRIO_1, HCAL, &cli_idle, cli_init, NULL );
RKH_SMA_CREATE( CLI_T, cli2, CLI_PRIO_2, HCAL, &cli_idle, cli_init, NULL );
RKH_SMA_CREATE( CLI_T, cli3, CLI_PRIO_3, HCAL, &cli_idle, cli_init, NULL );

RKH_ARRAY_SMA_CREATE( clis, NUM_CLIENTS ) 
{
	&cli0, &cli1, &cli2, &cli3
};


/*
 *	Defines states and pseudostates.
 */

RKH_CREATE_BASIC_STATE( cli_idle,
						cli_delay_req, NULL,  RKH_ROOT, NULL );
RKH_CREATE_TRANS_TABLE( cli_idle )

	RKH_TRREG( TOUT_REQ,	NULL,	cli_req,	&cli_waiting ),
	RKH_TRREG( PAUSE,		NULL,	NULL,		&cli_paused ),

RKH_END_TRANS_TABLE


RKH_CREATE_BASIC_STATE( cli_waiting, NULL, NULL,  RKH_ROOT, NULL );
RKH_CREATE_TRANS_TABLE( cli_waiting )

	RKH_TRREG( START,		NULL,	cli_start,	&cli_using ),

RKH_END_TRANS_TABLE


RKH_CREATE_BASIC_STATE( cli_using, NULL, NULL,  RKH_ROOT, NULL );
RKH_CREATE_TRANS_TABLE( cli_using )

	RKH_TRREG( TOUT_USING,	NULL,	cli_end,	&cli_idle ),
	RKH_TRREG( PAUSE,		NULL,	NULL,		&cli_paused ),

RKH_END_TRANS_TABLE


RKH_CREATE_BASIC_STATE( cli_paused, 
						cli_pause, cli_resume, RKH_ROOT, NULL );
RKH_CREATE_TRANS_TABLE( cli_paused )

	RKH_TRINT( TOUT_USING,	NULL, 	cli_end ),
	RKH_TRREG( PAUSE,		NULL,	NULL,		&cli_idle ),

RKH_END_TRANS_TABLE
\endcode

Prev: \ref shared_sm_cli \n

The related actions (entry, exit, guard, and state transition) to be 
executed by the state machine are implemented and declared in the 
\ref cliact_c "cliact.c" and \ref cliact_h "cliact.h" file, respectively. 
Note that the \c rkhcfg.h file defines the prototypes of them. \n \n

\anchor cliact_c
<STRONG> \"cliact.c\" - Client actions </STRONG>
\code
#include "rkh.h"
#include "cli.h"
#include "svr.h"
#include "bsp.h"

#include <stdlib.h>
#include <stdio.h>
#include <time.h>


#define CLI_REQ_TIME		\
			(RKH_TNT_T)RKH_TIME_SEC( (bsp_rand() % 5) + 2 )
#define CLI_USING_TIME		\
			(RKH_TNT_T)RKH_TIME_SEC( (bsp_rand() % 5) + 1 )


static RKH_DCLR_STATIC_EVENT( e_touse, TOUT_USING );
static RKH_DCLR_STATIC_EVENT( e_toreq, TOUT_REQ );
static RKH_DCLR_STATIC_EVENT( e_done, DONE );


/*
 *	Defines HSM init function
 */

void
cli_init( const struct rkhsma_t *sma )
{
	rkh_tim_init( &RKH_CAST(CLI_T, sma)->cli_utmr, &e_touse, NULL );
	rkh_tim_init( &RKH_CAST(CLI_T, sma)->cli_rtmr, &e_toreq, NULL );
}


/*
 *	Defines state entry functions
 */

void 
cli_pause( const struct rkhsma_t *sma )
{
	rkh_tim_stop( &RKH_CAST(CLI_T, sma)->cli_rtmr );
	bsp_cli_paused( RKH_GET_PRIO(sma) );
}


void 
cli_delay_req( const struct rkhsma_t *sma )
{
	RKH_TNT_T time;

	time = CLI_REQ_TIME;
	rkh_tim_oneshot( &RKH_CAST(CLI_T, sma)->cli_rtmr, sma, time );
	bsp_cli_wait_req( RKH_GET_PRIO(sma), time/BSP_TICKS_PER_SEC );
}


/*
 *	Defines state exit functions
 */

void 
cli_resume( const struct rkhsma_t *sma )
{
	bsp_cli_resumed( RKH_GET_PRIO(sma) );
}


/*
 *	Defines transition action functions
 */

void 
cli_req( const struct rkhsma_t *sma, RKH_EVT_T *pe )
{
	REQ_EVT_T *e_req;

	(void)pe;
	e_req = RKH_ALLOC_EVENT( REQ_EVT_T, REQ );
	e_req->clino = RKH_GET_PRIO(sma);
	RKH_SMA_POST_FIFO( svr, RKH_EVT_CAST(e_req), sma );
	bsp_cli_req( e_req->clino );
}


void 
cli_start( const struct rkhsma_t *sma, RKH_EVT_T *pe )
{
	RKH_TNT_T time;

	(void)pe;
	time = CLI_USING_TIME;
	rkh_tim_oneshot( &RKH_CAST(CLI_T, sma)->cli_utmr, sma, time );
	bsp_cli_using( RKH_CAST(START_EVT_T, pe)->clino, time/BSP_TICKS_PER_SEC );
}


void 
cli_end( const struct rkhsma_t *sma, RKH_EVT_T *pe )
{
	(void)pe;
	(void)sma;

	RKH_SMA_POST_FIFO( svr, &e_done, sma );
	bsp_cli_done( RKH_GET_PRIO(sma) );
}
\endcode

Prev: \ref shared_sm_cli \n \n

\anchor cliact_h
\n <STRONG> \"cliact.h\" - Client action declarations </STRONG>
\code
#ifndef __CLIACT_H__
#define __CLIACT_H__


#include "rkh.h"


/*
 *	Defines HSM init function
 */

void cli_init( const struct rkhsma_t *sma );


/*
 *	Defines state entry functions
 */

void cli_delay_req( const struct rkhsma_t *sma );
void cli_pause( const struct rkhsma_t *sma );


/*
 *	Defines state exit functions
 */

void cli_resume( const struct rkhsma_t *sma );


/*
 *	Defines transition action functions
 */

void cli_req( const struct rkhsma_t *sma, RKH_EVT_T *pe );
void cli_start( const struct rkhsma_t *sma, RKH_EVT_T *pe );
void cli_end( const struct rkhsma_t *sma, RKH_EVT_T *pe );


#endif
\endcode

Prev: \ref shared_sm_cli \n

\subsection shared_sm_svr Server state-machine implementation

The \ref svr_c "svr.c" file implements the state machine of Server active 
object, which illustrates some aspects of implementing state machines with 
RKH framework. Please correlate this implementation with the state diagram 
shown above. On the other hand, the header file \ref svr_h "svr.h" contains 
the definitions of object structures related to the state machine. 
See following sections:

- \ref svr_c "Server state machine representation - \"svr.c\""
- \ref svract_c "Server actions - \"svract.c\""
- \ref svract_h "Server action declarations - \"svract.h\""
 \n \n
\anchor svr_c 
<STRONG> \"svr.c\" - Server state machine representation </STRONG> \n
\code
#include "rkh.h"


/*
 *	Include file of HSM definitions.
 */

#include "svr.h"


/*
 *	Include file of action/guard definitions
 */

#include "svract.h"


/*
 *	Defines SMA (a.k.a Active Object) "svr".
 */

RKH_SMA_CREATE( SVR_T, svr, 0, HCAL, &svr_idle, svr_init, NULL );


/*
 *	Defines states and pseudostates.
 */

RKH_CREATE_BASIC_STATE( svr_idle, NULL, NULL,  RKH_ROOT, NULL );
RKH_CREATE_TRANS_TABLE( svr_idle )

	RKH_TRINT( TERM,	NULL,	svr_terminate ),
	RKH_TRREG( REQ,		NULL,	svr_start,	&svr_busy ),
	RKH_TRREG( PAUSE,	NULL,	NULL,		&svr_paused ),

RKH_END_TRANS_TABLE


RKH_CREATE_BASIC_STATE( svr_busy, NULL, NULL,  RKH_ROOT, NULL );
RKH_CREATE_TRANS_TABLE( svr_busy )

	RKH_TRINT( REQ,		NULL,	svr_defer ),
	RKH_TRINT( TERM,	NULL,	svr_terminate ),
	RKH_TRREG( DONE,	NULL,	svr_end,	&svr_idle ),
	RKH_TRREG( PAUSE,	NULL,	NULL,		&svr_paused ),

RKH_END_TRANS_TABLE


RKH_CREATE_BASIC_STATE(	svr_paused, 
						svr_pause, svr_resume, RKH_ROOT, NULL );
RKH_CREATE_TRANS_TABLE( svr_paused )

	RKH_TRINT( REQ,		NULL,	svr_defer ),
	RKH_TRINT( DONE,	NULL,	NULL ),
	RKH_TRINT( TERM,	NULL,	svr_terminate ),
	RKH_TRREG( PAUSE,	NULL,	NULL,		&svr_idle ),

RKH_END_TRANS_TABLE
\endcode

Prev: \ref shared_sm_svr \n

The related actions (entry, exit, guard, and state transition) to be 
executed by the state machine are implemented and declared in the 
\ref svract_c "svract.c" and \ref svract_h "svract.h" file, respectively. 
Note that the \c rkhcfg.h file defines the prototypes of them. \n \n

\anchor svract_c 
<STRONG> \"svract.c\" - Server actions </STRONG>
\code
#include "rkh.h"
#include "svr.h"
#include "cli.h"
#include "bsp.h"


#define MAX_SIZEOF_QREQ				2*NUM_CLIENTS


static RKH_RQ_T qreq;
static RKH_EVT_T *qreq_sto[ MAX_SIZEOF_QREQ ];


/*
 *	Defines HSM init function
 */

void 
svr_init( const struct rkhsma_t *sma )
{
	HInt cn;

	(void)sma;
	rkh_rq_init( &qreq, qreq_sto, MAX_SIZEOF_QREQ, NULL );

	RKH_CAST(SVR_T, sma)->ntot = 0;
	for( cn = 0; cn < NUM_CLIENTS; ++cn )
		RKH_CAST(SVR_T, sma)->ncr[ cn ] = 0;
}


/*
 *	Defines state entry functions
 */

void 
svr_pause( const struct rkhsma_t *sma )
{
	(void)sma;
	bsp_svr_paused( sma );
}


/*
 *	Defines state exit functions
 */

void 
svr_resume( const struct rkhsma_t *sma )
{
	REQ_EVT_T *e;

	if( (e = (REQ_EVT_T *)rkh_recall( (RKH_SMA_T*)sma, &qreq )) != NULL )
		bsp_svr_recall( e->clino );
}


/*
 *	Defines transition action functions
 */

void 
svr_start( const struct rkhsma_t *sma, RKH_EVT_T *pe )
{
	START_EVT_T *e_start;

	e_start = RKH_ALLOC_EVENT( START_EVT_T, START );
	e_start->clino = RKH_CAST(REQ_EVT_T, pe)->clino;
	RKH_SMA_POST_FIFO( RKH_GET_SMA( RKH_CAST(REQ_EVT_T, pe)->clino ), 
												RKH_EVT_CAST(e_start), sma );
	++RKH_CAST(SVR_T, sma)->ntot;
	++RKH_CAST(SVR_T, sma)->ncr[ CLI_ID(e_start->clino) ];
}


void 
svr_end( const struct rkhsma_t *sma, RKH_EVT_T *pe )
{
	REQ_EVT_T *e;

	(void)pe;
	if( (e = (REQ_EVT_T *)rkh_recall( (RKH_SMA_T*)sma, &qreq )) != NULL )
		bsp_svr_recall( e->clino );
}


void 
svr_defer( const struct rkhsma_t *sma, RKH_EVT_T *pe )
{
	(void)sma;
	rkh_defer( &qreq, pe );
}


void 
svr_terminate( const struct rkhsma_t *sma, RKH_EVT_T *pe )
{
	(void)sma;
	(void)pe;

	rkh_exit();
}
\endcode

Prev: \ref shared_sm_svr \n

\anchor svract_h 
\n <STRONG> \"svract.h\" - Server action declarations </STRONG>
\code
#ifndef __SVRACT_H__
#define __SVRACT_H__


#include "rkh.h"


/*
 *	Defines HSM init function
 */

void svr_init( const struct rkhsma_t *sma );


/*
 *	Defines state entry functions
 */

void svr_pause( const struct rkhsma_t *sma );


/*
 *	Defines state exit functions
 */

void svr_resume( const struct rkhsma_t *sma );


/*
 *	Defines transition action functions
 */

void svr_start( const struct rkhsma_t *sma, RKH_EVT_T *pe );
void svr_end( const struct rkhsma_t *sma, RKH_EVT_T *pe );
void svr_defer( const struct rkhsma_t *sma, RKH_EVT_T *pe );
void svr_terminate( const struct rkhsma_t *sma, RKH_EVT_T *pe );


#endif
\endcode

Prev: \ref shared_sm_svr \n

<HR>
\section shared_ao Signals, events, and active objects

In RKH, signals are typically enumerated constants and events with 
parameters are structures derived from the RKH_EVT_T base structure. The next 
listing shows signals and events used in the Shared application 
(\ref scevt_h "scevt.h"). \n \n

\anchor scevt_h 
<STRONG> \"scevt.h\" - Signals and events</STRONG>
\code
#ifndef __SCEVT_H__
#define __SCEVT_H__


#include "rkh.h"


/**
 * 	Signals
 */

typedef enum sc_sigs_t
{
	REQ,		/* client request */
	START,		/* use server */
	DONE,		/* release server  */
	TOUT_REQ,	/* timer expired */
	TOUT_USING,	/* timer expired */
	PAUSE,		/* press the key 'p' on the keyboard */
	TERM		/* press the key escape on the keyboard */
} SC_SIGS_T;


typedef struct
{
	RKH_EVT_T e;			/** base structure */
	rkhui8_t clino; 	/** client number (ID) */
} REQ_EVT_T;


typedef struct
{
	RKH_EVT_T e;			/** base structure */
	rkhui8_t clino; 	/** client number (ID) */
} START_EVT_T;


#endif
\endcode

\anchor svr_h 
<STRONG> \"svr.h\" - Server (svr) active object</STRONG>
\code
#ifndef __SVR_H__
#define __SVR_H__


#include "rkh.h"
#include "scevt.h"
#include "cli.h"


/* Helper macro */
#define CLI_ID( _cp )			((_cp) - RKH_GET_PRIO(CLI(0)))


typedef struct
{
	RKH_SMA_T sma;		                                   /* base structure */
	rkhui32_t ntot;		                /* total number of attended requests */
							  /* number of attended requests of every client */
	rkhui32_t ncr[ NUM_CLIENTS ];
} SVR_T;			        /* Active Object derived from RKH_SMA_T structure */


/*
 *	Declare HSM.
 */

RKH_SMA_DCLR( svr );


/*
 *	Declare states and pseudostates.
 */

RKH_DCLR_BASIC_STATE	svr_idle, svr_busy, svr_paused;


#endif
\endcode

\anchor cli_h 
<STRONG> \"cli.h\" - Client (cli) active object</STRONG>
\code
#ifndef __CLI_H__
#define __CLI_H__


#include "rkh.h"
#include "scevt.h"


#define CLI( _clino )			RKH_ARRAY_SMA( clis, _clino )
#define CLI0					CLI(0)
#define CLI1					CLI(1)
#define CLI2					CLI(2)
#define CLI3					CLI(3)


typedef enum cli_prio
{
	CLI_PRIO_0 = 1, CLI_PRIO_1, CLI_PRIO_2, CLI_PRIO_3,
	MAX_CLI_PRIO,
	NUM_CLIENTS = MAX_CLI_PRIO - 1,
}CLI_PRIO;


typedef struct
{
	RKH_SMA_T sma;		/* base structure */
	RKH_TMR_T cli_utmr; /* usage time */
	RKH_TMR_T cli_rtmr;	/* waiting request time */
} CLI_T;				/* Active Object derived from RKH_SMA_T structure */


/*
 *	Declare HSM.
 */

RKH_ARRAY_SMA_DCLR( clis, NUM_CLIENTS );


/*
 *	Declare states and pseudostates.
 */

RKH_DCLR_BASIC_STATE	cli_idle, cli_waiting, cli_using, cli_paused;


#endif
\endcode

\n <HR>
\section shared_init Initializing and starting the application

Most of the system initialization and application startup can be written 
in a platform-independent way. \n \n

\anchor shared_main_c 
<STRONG> \"main.c\" - main() function </STRONG>
\code
#include "rkh.h"
#include "rkhtrc.h"
#include "bsp.h"
#include "bky.h"
#include "bkyact.h"


#define QSTO_SIZE			4

static RKH_EVT_T *qsto[ QSTO_SIZE ];
extern RKH_TMR_T bkytim;


int
main( int argc, char *argv[] )
{
	bsp_init( argc, argv );

	/* set trace filters */
	RKH_FILTER_ON_GROUP( RKH_TRC_ALL_GROUPS );
	RKH_FILTER_ON_EVENT( RKH_TRC_ALL_EVENTS );
	RKH_FILTER_OFF_EVENT( RKH_TE_TIM_TOUT );
	RKH_FILTER_OFF_EVENT( RKH_TE_SM_STATE );
	RKH_FILTER_OFF_SMA( blinky );

	rkh_init();
	RKH_TRC_OPEN();

	RKH_TR_FWK_OBJ( blinky );
	RKH_TR_FWK_OBJ( &blinky->equeue );
	RKH_TR_FWK_OBJ( &led_on );
	RKH_TR_FWK_OBJ( &led_off );
	RKH_TR_FWK_OBJ( &bkytim );
	RKH_TR_FWK_SIG( TIMEOUT );

	rkh_sma_activate( blinky, (const RKH_EVT_T **)qsto, QSTO_SIZE, CV(0), 0 );
	rkh_enter();

	RKH_TRC_CLOSE();
	return 0;
}
\endcode

\n <HR>
\section shared_run Running on various platforms

As said before, the only platform-dependent file is the board support package 
(BSP) definition. Each of supported platforms defines its own \c bsp.c and 
\c bsp.h files, which are contained in the proper directory, for example, the 
BSP for the Shared application on Windows 32 (Visual Studio 2008) with a 
simple cooperative scheduler is located in 
\c \<rkh\>\\demo\\cross\\shared\\platform\\80x86\\win32_st\\vc08\\ 

<TABLE	align="center" valign="middle" width=70% cellSpacing=2 
		cellPadding=4 border=0>

	<TR bgColor="#c0c0c0">
		<TH><B> CPU Architecture </B></TH>
		<TH><B> Manufacturer </B></TH>
		<TH><B> MCU </B></TH>
		<TH><B> Evaluation Board </B></TH> 
		<TH><B> Toolchain </B></TH> 
		<TH><B> Comments </B></TH> 
		<TH><B> Notes </B></TH> 
	</TR>

	<TR bgColor="#f0f0f0" align="center" valign="middle" >
		<TD> Freescale </TD>
		<TD> S08 </TD>
		<TD> <A HREF="http://www.freescale.com/webapp/sps/
		site/prod_summary.jsp?code=S08QE">S08QE128</A> </TD>
		<TD> <A HREF="http://www.freescale.com/webapp/sps/site/
		prod_summary.jsp?code=DEMOQE128">DEMOQE128</A> </TD>
		<TD> Codewarrior v10.x </TD>
		<TD> Native cooperative scheduler </TD>
		<TD> \ref cross_demoqe128_s08 "readme" </TD>
	</TR>

	<TR bgColor="#c8cedc" align="center" valign="middle" >
		<TD rowspan="2"> 80x86 </TD>
		<TD> --- </TD>
		<TD> --- </TD>
		<TD> --- </TD>
		<TD> <A HREF="http://www.microsoft.com/en-us/download/
		details.aspx?id=5555">Visual Studio C++ 2010 </A> </TD>
		<TD> Win32 cooperative scheduler simulation </TD>
		<TD>  </TD>
	</TR>

	<TR bgColor="#c8cedc" align="center" valign="middle">
		<TD> --- </TD>
		<TD> --- </TD>
		<TD> --- </TD>
		<TD>  <A HREF="http://www.microsoft.com/en-us/download/
		details.aspx?id=5555">Visual Studio C++ 2010 </A> </TD>
		<TD> Win32 multithread </TD>
		<TD>  </TD>
	</TR>

</TABLE>

Prev: \ref cross "Cross-platform examples"\n
*/
