/**
\page preparing Preparing the application files
\image html rkh_bunner.jpg

\n
\ref basics "< Basics"\n
\ref identify_events "> Identifying, generating and sending events"\n\n

The sample code for the example presented above ported to x86 is located 
in the directory \c \\demo\\80x86\\vc08\\win32_st\\vc08\\ahsm. It contains 
the Visual C++ 2008 project files to build the application. Also, emulates 
a ISR and a simple event-loop like a cooperative scheduler 
using the native priority scheme among other RKH services. 
See \ref Installation section about RKH files. The application files 
are listed below: 

- \b "bsp.h":		contains the interface to the board support package and 
					is located in the application directory.
					See the \subpage bsp_h file.

- \b "my.h": 		contains the definitions of objet structures (state 
					machine, states, and pseudostates) and other facilities 
					shared among the components of the application. 
					See the \subpage my_h file.

- \b "myact.h":		defines the actions to be executed.
					Note that the \b rkhcfg.h file defines the function
					prototype of actions. See \ref cfg section about of 
					available options and \subpage myact_c file.
					See the \subpage myact_h file.

- \b "rkhcfg.h":	adapts and configures RKH. See \ref cfg section. 
					In the \\demo directory there are other \b rkhcfg.h files
					already in existence and it's suggested that these 
					are used as a reference.

- \b "trazer.h":	implements a simple trace analyzer. 
					See the \subpage trazer_h file.

- \b "bsp.c":		contains the implementation of the board-specific 
					functions. 
					See the \subpage bsp_c file.

- \b "main.c": 		contains the \c main() function along with 
					an example for using the RKH trace facility.
					See the \subpage main_c file.

- \b "my.c": 		this module implements the \c my state machine, which 
					illustrates all aspects of implementing state machines 
					with RKH framework. Please correlate this implementation 
					with the \c my state diagram in \ref fig1 "Figure 1".
					See the \subpage my_c file.

- \b "myact.c": 	declares each of entry, exit, transition, and guard 
					actions to be executed.
					Note that the \b rkhcfg.h file defines the function
					prototype of actions. See \ref cfg section about of 
					available options and \subpage myact_c file.

- \b "trazer.c":	contains the implementation of the trace analyzer. 
					See the \subpage trazer_c file.

\n
\ref basics "< Basics"\n
\ref identify_events "> Identifying, generating and sending events"\n\n
*/


/**
\page identify_events Identifying, generating and sending events
\image html rkh_bunner.jpg

\n
\ref preparing "< Preparing the application files"\n
\ref identify "> Identifying and classifying states and pseudostates"\n

The events in the \c my state machine have been identified in the state 
diagram in \ref fig1 "Figure 1". Note that events consist really of two 
parts. The part of the event called the signal conveys the type of the 
occurrence (what happened). For example, the ONE signal conveys the 
arrival of a press key '1'. An event can also contain additional 
quantitative information about the occurrence in form of event parameters. 
In \c my state machine, all signals are accompanied by the parameter (ts) 
that contain the quantitative information as to timestamp. In RKH, events 
are represented as instances of the RKHEVT_T structure provided by the 
framework. Specifically, the RKHEVT_T structure contains the member \c e, 
to represent the signal of that event. Event parameters are added in the 
process of \link RKHEVT_T inheritance \endlink.

- \ref ide_e
- \ref gen_e

<HR>
\section ide_e Identifying events

Because events are explicitly shared among most of the application 
components, it is convenient to declare them in the separate header file 
\subpage my_h, which is shown below.

\code
/*
 *	my.h
 */


#ifndef __MY_H__
#define __MY_H__


#include "rkh.h"


/*
 * 	Signals
 */

enum
{
	ZERO,		/* press the key '0' on the keyboard */
	ONE,		/* press the key '1' on the keyboard */
	TWO,		/* press the key '2' on the keyboard */
	THREE,		/* press the key '3' on the keyboard */
	FOUR,		/* press the key '4' on the keyboard */
	FIVE,		/* press the key '5' on the keyboard */
	SIX,		/* press the key '6' on the keyboard */
	TERM		/* press the key escape on the keyboard */
};


typedef struct
{
	RKHEVT_T event;
	rkhui16_t ts;
} MYEVT_T;

...

#endif
\endcode

<HR>
\section gen_e Generating and posting events

RKH supports the simple mechanism of direct event posting supported through 
the functions rkh_sma_post_fifo() and rkh_sma_post_lifo(), where the producer 
of an event directly posts the event to the event queue of the consumer active 
object (SMA).
In RKH, any part of the system can produce events, not necessarily only the 
SMAs. For example, interrupt service routines (ISRs) or device drivers can 
also produce events. On the other hand, only SMAs can consume events, 
because only SMAs have event queues. The following listing provides examples 
of posting dynamic and static events from the interrupt service routines 
(ISRs) of the \c ahsm demo application version for the win32 single thread, 
\subpage bsp_c file. 

\code

	#define ESC				0x1B
	#define kbmap( c )		( (c) - '0' )

(1)	static RKH_DCLR_STATIC_EVENT( eterm, TERM );

	...

	static 
	DWORD WINAPI 
(2)	isr_kbd_thread( LPVOID par )	/* Win32 thread to emulate keyboard ISR */
	{
		int c;
		MYEVT_T *mye;

		( void )par;
		while( running ) 
		{
			c = _getch();
			
			if( c == ESC )
(3)				rkh_sma_post_fifo( my, &eterm );
			else
			{
(4)				mye = RKH_ALLOC_EVENT( MYEVT_T, kbmap( c ) );
(5)				mye->ts = ( rkhui16_t )rand();
(6)				rkh_sma_post_fifo( my, ( RKHEVT_T* )mye );
			}
		}
		return 0;
	}
\endcode


\li (1) The TERM event never changes, so it can be statically allocated just 
		once. The RKH_DCLR_STATIC_EVENT() macro declares and initializes the 
		event structure \e eterm with \a TERM signal and establishes it as 
		one static event. The created event object is explicitly placed in ROM.
\li (2)	Win32 thread to emulate keyboard ISR.
\li (3) The static event is posted directly to the \c my SMA.
\li (4) The macro RKH_ALLOC_EVENT() dinamically allocates an instance of 
		MYEVT_T event from an event pool. The macro also performs the 
		association between the signal and the allocated event.
		The signals are generated from the key strokes by means of 
		\c kbmap() macro.
\li (5) The \c ts parameter of the event is assigned.
\li (6) The dynamic event is posted directly to the \c my SMA..

\n
\ref preparing "< Preparing the application files"\n
\ref identify "> Identifying and classifying states and pseudostates"\n
*/


/**
\page identify Identifying and classifying states and pseudostates
\image html rkh_bunner.jpg

\n
\ref identify_events "< Identifying, generating and sending events"\n
\ref representing "> Representing the state machine"\n\n

The \ref fig2 "Figure 2" shows the states and pseudostates from the diagram
presented above, sorted by state nesting level.

\n
\anchor fig2
\image html sttbl.jpg "Figure 2 - State nesting"

\n
\ref identify_events "< Identifying, generating and sending events"\n
\ref representing "> Representing the state machine"\n\n
*/


/**
\page representing Representing the state machine
\image html rkh_bunner.jpg

\n
\ref identify "< Identifying and classifying states and pseudostates"\n
\ref running "> Running"\n\n

Now, this section explains how to implement the \c my state machine 
using the RKH framework, which is shown in \ref fig1 "Figure 1".

- \subpage rep_sm
- \subpage rep_cs
- \subpage rep_bs
- \subpage rep_cjh
- \subpage rep_def
- \subpage rep_act
- \subpage rep_inc

\n
\ref identify "< Identifying and classifying states and pseudostates"\n
\ref running "> Running"\n\n

*/

/**
\page basics Basics
\image html rkh_bunner.jpg

\n
\ref Usage "< Representing a state machine"\n
\ref preparing "> Preparing the application files"\n\n

As mentioned previously, RKH is a generic, flexible, modular, highly portable, 
ANSI-C compliant, and open-source development tool for implementing 
hierarchical state machines based on modern state machine concepts. This 
modern techniques are used to give an abstract description of the dynamic 
behavior of a system in a substantial manner.

<STRONG> The key features of the RKH framework: </STRONG>

- State machines representation is based on state tables.
- Representing a state machine with RKH is intuitive, and easy.
- Reflects the state diagram without obfuscation.
- The RKH application are highly maintainable.
- Easy to integrate with any event queuing and dispatching mechanism.
- Useful in embedded systems.
- The most of the RKH implementation is \ref Porting "independent of any particular CPU, operating system, or compiler".
- Flexible and \ref cfg "user-configurable code generation".
- Very small footprint.
- Include a \link rkhs.h dispatching event mechanism \endlink based on active object's priority.
- Include a \link rkhrq.h queue module \endlink
- Include a \link rkhtim.h software timer module \endlink.
- Include a \link rkhmp.h fixed-size memory block module \endlink.
- Include a native \ref dbg.
- Support hierarchically nested states, and flat state machine.
- Support multiple state machines.
- Support conditional, junction, and history pseudostates.
- Support compound transitions with guards.
- Support local transitions.
- Include mechanism for \link rkh_defer() deferring events\endlink.
- Support \link RKHEVT_T event dispatching with parameters\endlink.
- Include \link RKHEVT_T dynamic events\endlink.
- Support a easy way to use \link RKHEVT_T events with arguments\endlink.
- Support systems-friendly \link RKHASSERT() assertion\endlink macros like assert, allege, error, require, and ensure.


The RKH not implements neither entire UML specs. nor entire Statechart specs. 
Instead, the RKH intention is to support just enough basic concepts of that 
powerful tools to facilitate the reactive-system modeling holding a solid, 
and efficient implementation. Broadly speaking, the RKH implementation has 
been designed from the ground up to be used in 8-bits platforms but can be 
easily adapted to 16 or 32-bits platforms.

\ref Usage "< Representing a state machine"\n
\ref preparing "> Preparing the application files"
*/


/**
\page rep_sm 1. Instantiating the state machine (and defining the top state)
\image html rkh_bunner.jpg

\n
\ref representing "< Representing the state machine"\n
\ref rep_cs "> Instantiating the composite states"\n\n

A state machine application (SMA) a.k.a active object, is defined with the 
RKH_SMA_CREATE() macro and declared with the RKH_SMA_DCLR() macro. Frequently, 
each state machine application is encapsulated inside a dedicated source 
file (.c file), from which the RKH_SMA_CREATE() macro is used, thus the 
structure definition is in fact entirely encapsulated in its module and is 
inaccessible to the rest of the application. However, as a general rule, 
the SMA must be declared inside a header file (.h file) by means of 
RKH_SMA_DCLR() macro. This macro declares a opaque pointer to SMA to be 
used as a global object. This global pointer represent the state machine 
in the application. The state machine pointers are "opaque" because they 
cannot access the whole state machine structure, but only the part inherited 
from the RKHSMA_T structure. The power of an "opaque" pointer is that it 
allows to completely hide the definition of the state machine structure and 
make it inaccessible to the rest of the application. 

In the UML specification, every state machine has a top state 
(the abstract root of every state machine hierarchy), which contains 
all the other elements of the entire state machine. RKH provides the 
top state using the macro RKH_SMA_CREATE().
requently, RKH_SMA_CREATE() is used within state-machine's module 
(.c file), thus the structure definition is in fact entirely encapsulated 
in its module and is inaccessible to the rest of the application. 
However, use the RKH_SMA_DCLR() macro to declare a "opaque" pointer 
to that state machine application structure to be used in the rest of the 
application but hiding the proper definition.
RKHSMA_T is not intended to be instantiated directly, but rather
serves as the base structure for derivation of state machines in the
application code.

The \ref its "Figure 2" highlights the top state and its relevant aspects. 
Also, shows its implementation using the RKH framework.

\n
\anchor its
\image html its.png "Figure 2 - Top state of state machine \c my"
\n

<b>Defining the state machine</b>
\n
\code
	//	my.c: state machine application's module

(1) RKH_SMA_CREATE( 	
(2)						MYSM_T, 
(3)						0, 
(4)						my, 
(5)						0, 
(6)						HCAL, 
(7)						&S1, 
(8)						my_init, 
(9)						NULL );
\endcode

<b>Declaring the state machine</b>
\n
\code
	//	my.h: state-machine application's header file

	typedef struct
	{
		RKHSMA_T sm;	// base structure
		rkhuint8 x;		// private member
		rkhuint8 y;		// private member
(10)} MYSM_T;			// SMA derived from RKHSMA_T structure

(11) RKH_SMA_DCLR( my );
\endcode

Explanation

\li (1)	Declares and allocates a SMA (a.k.a active object) derived from 
		RKHSMA_T.
\li (2)	As said before, \c MYSM_T represents the SMA object struture.
\li (3)	\c 0 is the SMA ID. This number allows to uniquely identify a SMA. 
		This argument is optional, thus it could be eliminated in 
		compile-time with RKH_SMA_EN_ID = 0.
\li (4)	\c my is the name of SMA. Also, it represents the top state of state 
		diagram. 
\li (5)	\c 0 is the SMA priority. A unique priority number must be assigned 
		to each SMA from 0 to RKH_LOWEST_PRIO. The lower the number, the 
		higher the priority. 
\li (6)	the \c my state machine is defined as a hierarchical state machine. 
		The available property options are enumerated in RKH_HPPTY_T 
		enumeration in the \b rkh.h file.
\li (7)	\c S1 is the initial state.
\li (8)	the \c my_init() function defines the topmost initial transition in 
		the \c my state machine. 
		The function prototype is defined as RKHINIT_T. This argument is 
		(optional), thus it could be declared as NULL.
\li (9) not used.
\li (10)The \c MYSM_T defines the SMA object structure \c my.
		On the other hand, almost every SMA must also store other 
		"extended-state" information. You supply this additional information 
		by means of data members enlisted after the base structure member
		\c sm. Please note that the RKHSMA_T member \c sm is defined as the 
		\b FIRST member of the derived struct.
		RKHSMA_T is not intended to be instantiated directly, but rather 
		serves as the base structure for derivation of state machines in the 
		application code.
\li (11)Declares a opaque pointer to \c my SMA to be used as a global object.

\n
\ref representing "< Representing the state machine"\n
\ref rep_cs "> Instantiating the composite states"\n\n
*/


/**
\page rep_cs 2. Instantiating the composite states
\image html rkh_bunner.jpg

\n
\ref rep_sm "< Instantiating the state machine"\n
\ref rep_bs "> Declaring the basic states"\n\n

A superstate or composite state is defined with the RKH_CREATE_COMP_STATE()
macro and declared with the RKH_DCLR_COMP_STATE() macro. Frequently, each 
state machine and its states (superstates and substates) are encapsulated 
inside a dedicated source file (.c file), from which the 
RKH_CREATE_COMP_STATE() macro is used.

The \ref is1 "Figure 3" highlights the state "S1" and its relevant aspects. 
Also, shows its implementation using the RKH framework.

\n
\anchor is1
\image html is1.png "Figure 3 - composite state \"S1\""

\n
<b>Defining the composite state "S1"</b>
\n
\code
(1)	//	my.c: state-machine's module

(2)	RKH_CREATE_COMP_STATE( 	S1, 
(3)							0, 
(4)							set_y_0, 
(5)							dummy_exit, 
(6)							RKH_ROOT, 
(7)							&S11, 
(8)							&DH );
\endcode

<b>Declaring the composite state "S1"</b>
\n
\code
//	my.h: state-machine's header file

RKH_DCLR_COMP_STATE( S1 );
\endcode

Explanation

\li (1)	Frequently, each state machine and its states are encapsulated 
		inside a dedicated source file (.c file), from which the 
		RKH_CREATE_COMP_STATE() macro is used.
\li (2)	\c S1 is the state name. Represents a composite state structure.
\li (3)	\c 0 is the value of state ID.
\li (4)	\c set_y_0() defines the entry action to be executed unconditionally 
		upon the entry to the \c S1 state. This argument is optional, 
		thus it could be declared as NULL. The RKHENT_T defines the function 
		prototype.
\li (5)	\c dummy_exit() defines the exit action, which is executed upon exit 
		from the \c S1 state. This argument is optional, thus it could be 
		declared as NULL. The RKHEXT_T defines the function prototype.
\li (6)	\c RKH_ROOT is the parent state of \c S1. If a state has no 
		explicit superstate means that it is implicitly nested in 
		the "top" state, and the parent state is defined by means of RKH_ROOT
		macro.  The "top" state is a UML concept that denotes 
		the ultimate root of the state hierarchy in a hierarchical state 
		machine.
\li (7)	\c S11 is the default state of \c S1 state machine. At each level 
		of nesting, a superstate can have a private initial transition that
		designates the active substate after the superstate is entered 
		directly. Here the initial transition of state \c S1 designates the 
		state \c S11 as the initial active substate.
\li (8)	\c DH is the deep history pseudostate. This argument is optional, thus 
		it could be declared as NULL. See RKH_CREATE_SHALLOW_HISTORY_STATE() 
		macro and RKH_CREATE_DEEP_HISTORY_STATE().

In RKH every state is associated with a transition table, which is composed 
of a well-defined set of transitions.
The general syntax of an expression labelling a transition in a statechart is
\e "i[c]/a" where \e i is the input that triggers the transition, \e c is a 
condition that guards the transition from being taken unless it is true when 
\e i occurs, and \e a is an action that is carried out if and when the 
transition is taken. All of these parts are optional. 
Thus, in RKH each row in a table represents a transition, which is 
well-defined by an \e event, a \e guard, an \e action, and \e target state 
(or pseudostate). The \ref is1 "Figure 3" shows the transition table of "S1".

The following figures, \ref is3 "Figure 5", and 
\ref is11 "Figure 6" highlights the composite states "S3", and "S11". 
Also, shows its implementation using the RKH framework.

\n
\anchor is3
\image html is3.png "Figure 5 - composite state \"S3\""

\n
\anchor is11
\image html is11.png "Figure 6 - composite state \"S11\""

\n

\n
\ref rep_sm "< Instantiating the state machine"\n
\ref rep_bs "> Declaring the basic states"\n\n

*/


/**
\page rep_bs 3. Declaring the basic states
\image html rkh_bunner.jpg

\n
\ref rep_cs "< Instantiating the composite states"\n
\ref rep_cjh "> Declaring the pseudostates"\n\n

A basic state (also called substate) is defined with the 
RKH_CREATE_BASIC_STATE() macro and declared with the RKH_DCLR_BASIC_STATE() 
macro. Frequently, each state machine and its states (superstates and 
substates) are encapsulated inside a dedicated source file (.c file), from 
which the RKH_CREATE_BASIC_STATE() macro is used.
As will demostrates the use of RKH_CREATE_BASIC_STATE() macro and its
arguments is very similar to RKH_CREATE_COMP_STATE() macro.

The \ref is2 "Figure 7" highlights the basic states "S2". Also, shows its 
implementation using the RKH framework.

\n
\anchor is2
\image html is2.png "Figure 7 - basic state \"S2\""

<b>Defining the basic state "S2"</b>
\n
\code
(1)	//	my.c: state-machine's module

(2)	RKH_CREATE_BASIC_STATE( S2, 
(3)							0, 
(4)							NULL, 
(5)							NULL, 
(6)							RKH_ROOT, 
(7)							NULL );
\endcode

<b>Declaring the basic state "S2"</b>
\n
\code
//	my.h: state-machine's header file

RKH_DCLR_BASIC_STATE( S2 );
\endcode

Explanation

\li (1)	Frequently, each state machine and its states are encapsulated 
		inside a dedicated source file (.c file), from which the 
		RKH_CREATE_BASIC_STATE() macro is used.
\li (2)	\c S2 is the state name. Represents a substate structure.
\li (3)	\c 0 is the value of state ID.
\li (4)	the entry action is unused, therefore it is declared as NULL.
\li (5)	the exit action is unused, therefore it is declared as NULL.
\li (6)	\c RKH_ROOT is the parent state of \c S2. If a state has no 
		explicit superstate means that it is implicitly nested in 
		the "top" state, and the parent state is defined by means of RKH_ROOT
		macro.  The "top" state is a UML concept that denotes 
		the ultimate root of the state hierarchy in a hierarchical state 
		machine.
\li (7)	\c the event preprocessor action is unused, therefore it is 
		declared as NULL. 
		Before sending the arrived event to state machine, it can be 
		previously processed using the event preprocessor function. An 
		action function takes the state 
		machine pointer and the event pointer as arguments. The first 
		parameter is optional in compile-time according to 
		RKH_SMA_EN_PPRO_ARG_SMA macro.
		Example:
\code
static
RKHE_T
in_keyb( RKHEVT_T *pe )
{
	if( pe->e >= 0 && pe->e <= 9 )
		return DECIMAL;
	if( pe->e == '.' )
		return POINT;
	else
		return pe->e;
}
\endcode

\li (7)	\copydetails RKHSREG_T::prepro

\n
The following figures, \ref is111_s112 "Figure 8", 
\ref is12 "Figure 9", and \ref is31_s32 "Figure 10" highlights the 
basic states "S111", "S112", "S31", "S32", and "S12" respectively. 
Also, shows its implementation using the RKH framework.

\n
\anchor is111_s112
\image html is111_s112.png "Figure 8 - basic states \"S111\", and \"S112\""

\n
\anchor is12
\image html is12.png "Figure 9 - basic state \"S12\""

\n
\anchor is31_s32
\image html is31_s32.png "Figure 10 - basic states \"S31\", and \"S32\""

\n
\ref rep_cs "< Instantiating the composite states"\n
\ref rep_cjh "> Declaring the pseudostates"\n\n
*/


/**
\page rep_cjh 4. Declaring the pseudostates
\image html rkh_bunner.jpg

\n
\ref rep_bs "< Declaring the basic states"\n
\ref rep_def "> Defining the state machine's objects"\n\n

The conditional, junction, shallow history, and deep history pseudostates 
are created using RKH_CREATE_COND_STATE(), RKH_CREATE_JUNCTION_STATE(), 
RKH_CREATE_SHALLOW_HISTORY_STATE(), and RKH_CREATE_DEEP_HISTORY_STATE() 
macros respectively, which are defined in \b rkh.h file. Also, these macros
are broadly explained in the \ref qref section. 

The following figures, \ref ic1 "Figure 11", \ref ic2 "Figure 12", 
\ref ij "Figure 13", and \ref ih "Figure 14" highlights the 
pseudostates "C1", "C2", "J", "H", and "DH" respectively. 
Also, shows its implementation using the RKH framework.

\n
\anchor ic1
\image html ic1.png "Figure 11 - conditional pseudostate \"C1\""

\n
\anchor ic2
\image html ic2.png "Figure 12 - conditional pseudostate \"C2\""

A condition connector has one incoming transition and can have several 
outgoing transition segments called branches. Branches are labeled with 
guards that determine which one is to be actually taken. 
Since the condition connector is an OR connector, only one of the branches 
can be taken. Each condition connector can have one special branch with 
a guard labeled rkh_else, which is taken if all the guards on the other 
branches are false. 
Branches cannot contain triggers, but in addition to a guard they may 
contain actions. A branch can enter another condition connector, thus 
providing for the nesting of branches.
In RKH branches are defined by the macro RKH_BRANCH().
The general syntax of an expression labelling a branch in a statechart is
\e "[c]/a" where \e c is a condition that guards the transition from being 
taken unless it is true, and \e a is an action that is carried out if and 
when the transition is taken. All of these parts are optional. 
The following listing shows the C2's branch table:

\code
(1)	RKH_CREATE_BRANCH_TABLE( C2 )
(2)		RKH_BRANCH( x1, 		dummy_act,		&S3		),
		RKH_BRANCH( x2_or_x3, 	NULL,			&S32 	),
(3)		RKH_BRANCH( ELSE, 		NULL,			&S2 	),
(4)	RKH_END_BRANCH_TABLE
\endcode

Explanation

\li (1)	The RKH_CREATE_BRANCH_TABLE() macro creates the "C2"'s 
branch table. Each table type always begins with the macro 
RKH_CREATE_BRANCH_TABLE() and ends with the macro RKH_END_BRANCH_TABLE().
As noted above, sandwiched between these macros are the segment macros 
that actually comprise the condition connector.

\li (2)	The RKH_BRANCH() macro defines a branch segment, where 
\c x1() is the guard function, \c dummy_act() is the action function 
to be taken, and "S3" is the target state.

\li (3)	If all the guards on the other branches are false \c abort function 
will be invoked, and "S2" will be the next state.

\li (4)	The RKH_END_BRANCH_TABLE() macro ends branch table.

As said above, the actions and guards in RKH framework are represented by 
functions.

\n
\anchor ij
\image html ij.png "Figure 13 - junction pseudostate \"J\""

\n
\anchor ih
\image html ih.png "Figure 14 - history pseudostates \"H\" and \"DH\""

\n
\ref rep_bs "< Declaring the basic states"\n
\ref rep_def "> Defining the state machine's objects"\n\n
*/


/**
\page rep_def 5. Declaring the state machine's objects 
\image html rkh_bunner.jpg

\n
\ref rep_cjh "< Declaring the pseudostates"\n
\ref rep_act "> Declaring the actions"\n\n

The \subpage my_h file contains the definitions of objet structures (state 
machine, states, and pseudostates) and other facilities shared among 
the components of the application. See the \subpage my_h file.
The following listing shows the \subpage my_h header file, which illuminates 
some important aspects of implementing state machines with RKH.

\code
#ifndef __MY_H__
#define __MY_H__


(1)	#include "rkh.h"


   	/*
 	 * 	Signals
 	 */

(2) enum
	{
		ZERO,		/* press the key '0' on the keyboard */
		ONE,		/* press the key '1' on the keyboard */
		TWO,		/* press the key '2' on the keyboard */
		THREE,		/* press the key '3' on the keyboard */
		FOUR,		/* press the key '4' on the keyboard */
		FIVE,		/* press the key '5' on the keyboard */
		SIX,		/* press the key '6' on the keyboard */
		TERM		/* press the key escape on the keyboard */
	};


	typedef struct
	{
(3)		RKHEVT_T event;	/* base structure */
(4)		rkhuint16 ts;	/* parameter 'ts'. Private member */
	} MYEVT_T;			/* derived from RKHEVT_T structure */


	typedef struct
	{
		RKHSMA_T sma;	/* base structure */
		rkhui8_t x;		/* private member */
		rkhui8_t y;		/* private member */
(5) } MYSM_T;			/* SMA derived from RKHSMA_T structure */


/*	Declare the state machine */

(6)	RKH_SMA_DCLR( my );


/*	Defines states and pseudostates. */

(7)	RKH_DCLR_COMP_STATE		S1,S3,S11;
	RKH_DCLR_BASIC_STATE	S2,S31,S32,S111,S112,S12;
	RKH_DCLR_COND_STATE		C1,C2;
	RKH_DCLR_JUNC_STATE		J;
	RKH_DCLR_DHIST_STATE	DH;
	RKH_DCLR_SHIST_STATE	H;


#endif
\endcode

\li (1) RKH interfaces.

\li (2) The events in the \c my state machine have been identified in the 
state diagram in \ref fig1 Figure 1. Note that events consist really of two 
parts. The part of the event called the signal conveys the type of the 
occurrence (what happened). For example, the ONE signal conveys the arrival 
of a press key '1'. An event can also contain additional quantitative 
information about the occurrence in form of event parameters. In \c my state 
machine, all signals are accompanied by the parameter (ts) that contain the 
quantitative information as to timestamp. In RKH, events are represented as 
instances of the RKHEVT_T structure provided by the framework. Specifically, 
the RKHEVT_T structure contains the member e, to represent the signal of that 
event. Event parameters are added in the process of inheritance. Because events 
are explicitly shared among most of the application components, 
it is convenient to declare them in the separate header file \subpage my_h.

\li (3-4) The MYEVT_T structure declares an event with the parameter "ts".
		Such nesting of structures always aligns the data member 
		#RKHEVT_T at the beginning of every instance of the derived 
		structure. In particular, this alignment lets treat a pointer to 
		the derived MYEVT_T structure as a pointer to the #RKHEVT_T 
		base structure. Consequently, can always safely pass a pointer 
		to MYEVT_T to any C function that expects a pointer to #RKHEVT_T.

\li (5) The MYSM_T defines the SMA object structure \c my. On the other hand, 
		almost every SMA must also store other "extended-state" information. 
		You supply this additional information by means of data members 
		enlisted after the base structure member sm. Please note that the 
		RKHSMA_T member sm is defined as the FIRST member of the derived 
		struct. RKHSMA_T is not intended to be instantiated directly, but 
		rather serves as the base structure for derivation of state machines 
		in the application code.

\li (6) Declares a opaque pointer to \c my SMA to be used as a global object.

\li (7) Defines the states and pseudostates using the corresponding macros
		listed above:
		\n
		\n
		- #RKH_DCLR_COMP_STATE: 	composite state.
		- #RKH_DCLR_BASIC_STATE: 	basic state.
		- #RKH_DCLR_COND_STATE: 	conditional pseudostate.
		- #RKH_DCLR_JUNC_STATE: 	junction pseudostate.
		- #RKH_DCLR_DHIST_STATE: 	deep history pseudostate.
		- #RKH_DCLR_SHIST_STATE: 	shallow history pseudostate.

\n
\ref rep_cjh "< Declaring the pseudostates"\n
\ref rep_act "> Declaring the actions"\n\n
*/


/**
\page rep_act 6. Declaring the actions
\image html rkh_bunner.jpg

\n
\ref rep_def "< Defining the state machine's objects"\n
\ref rep_inc "> Include files"\n\n

All init, entry, exit, and transition actions of \c my state machine 
are implemented in \subpage myact_c file and declaring in 
\subpage myact_h file. These files also includes transition guard 
and branch selection functions.

- \ref in_a
- \ref tr_a
- \ref en_a
- \ref ex_a
- \ref gu_a
- \ref br_a

<HR>
\section in_a Initial action of \c my state machine

\code
void 
my_init( const struct rkh_t *ph )
{
	CMY( sma )->x = CMY( sma )->y = 0;
}
\endcode

<HR>
\section tr_a Transition actions of \c my state machine

\code
void
set_y_2( const struct rkh_t *ph, RKHEVT_T *pe )
{
	(void)pe;
	CMY( sma )->y = 2;
}


void
set_y_1( const struct rkh_t *ph, RKHEVT_T *pe )
{
	(void)pe;
	CMY( sma )->y = 1;
}


void
dummy_act( const struct rkh_t *ph, RKHEVT_T *pe )
{
	(void)sma;
	(void)pe;
}


void
show_data( const struct rkh_t *ph, RKHEVT_T *pe )
{
	(void)sma;
	(void)pe;
}
\endcode

<HR>
\section en_a Entry actions of \c my state machine

\code
void
set_x_1( const struct rkhsma_t *sma )
{
	CMY( sma )->x = 1;
}


void
set_x_2( const struct rkhsma_t *sma )
{
	CMY( sma )->x = 2;
}


void
set_x_3( const struct rkhsma_t *sma )
{
	CMY( sma )->x = 3;
}


void
set_y_0( const struct rkhsma_t *sma )
{
	CMY( sma )->y = 0;
}
\endcode

<HR>
\section ex_a Exit actions of \c my state machine

\code
void 
dummy_exit( const struct rkh_t *ph )
{
	(void)sma;
}
\endcode

<HR>
\section gu_a Transition guard functions of \c my state machine

\code
HUInt
x_equal_1( const struct rkh_t *ph, RKHEVT_T *pe )
{
	pd = rkh_get_data( ph );

	return pd->x == 1 ? RKH_GTRUE : RKH_GFALSE;
}
\endcode

<HR>
\section br_a Branch selection functions of \c my state machine

\code
HUInt
y0( const struct rkhsma_t *sma, RKHEVT_T *pe )
{
	(void)pe;
	return CMY( sma )->y == 0 ? RKH_GTRUE : RKH_GFALSE;
}


HUInt
y1( const struct rkhsma_t *sma, RKHEVT_T *pe )
{
	(void)pe;
	return CMY( sma )->y == 1 ? RKH_GTRUE : RKH_GFALSE;
}


HUInt
y2( const struct rkhsma_t *sma, RKHEVT_T *pe )
{
	(void)pe;
	return CMY( sma )->y == 2 ? RKH_GTRUE : RKH_GFALSE;
}


HUInt
x1( const struct rkhsma_t *sma, RKHEVT_T *pe )
{
	(void)pe;
	return CMY( sma )->x == 1 ? RKH_GTRUE : RKH_GFALSE;
}


HUInt
x2_or_x3( const struct rkhsma_t *sma, RKHEVT_T *pe )
{
	(void)pe;
	return CMY( sma )->x == 2 || CMY( sma )->x == 3 ? RKH_GTRUE : RKH_GFALSE;
}
\endcode

\n
\ref rep_def "< Defining the state machine's objects"\n
\ref rep_inc "> Include files"\n\n
*/


/**
\page rep_inc 7. Include files
\image html rkh_bunner.jpg

\n
\ref rep_act "< Declaring the actions"\n
\ref representing "> Representing the state machine"\n\n

The application C-file \subpage my_c that uses RKH must include a few 
header files. 

\code
(1) #include "rkh.h"


/* Includes file of HSM definitions. */

(2) #include "my.h"


/* Includes file of action/guard definitions. */

(3) #include "myact.h"

	...

\endcode

\li (1) Every application C-file that uses RKH must include the \b rkh.h 
		header file. This header file contains the specific adaptation 
		of RKH to the given processor and compiler, also includes the
		RKH interface to implement state machines. The port file is located
		in the application directory.

\li (2) The \subpage my_h header file contains the definitions of object 
		structures (state machine, states, and pseudostates), event 
		declaration, and other facilities shared among the components of 
		the application.

\li (3) This header file declares the actions to be executed.

\n
\ref rep_act "< Declaring the actions"\n
\ref representing "> Representing the state machine"\n\n
*/


/**
\page running Running
\image html rkh_bunner.jpg

\n
\ref representing "< Representing the state machine"\n
\ref Usage "> Representing a state machine: step by step"\n\n

\copydetails rkhs.h

<b>Application-specific and port dependencies</b>

First of all, pay special attention to \ref Porting and 
\ref Installation sections and then following the win32 single thread demo 
and its own port from the directories \\demo\\80x86\\win32_st\\vc08 and 
\\source\\portable\\80x86\\win32_st\\vc08 respectively.
<EM>The main goal to this is to make it easy to understand the 
event-driven code and experiment with it.</EM>

<b>Main function</b>

As said above, following the win32 single thread demo and its own port 
from the directories \\demo\\80x86\\win32_st\\vc08 and 
\\source\\portable\\80x86\\win32_st\\vc08 respectively. 
However, the \c main() function is shown below to illustrate the RKH concept.

\code
int
main( int argc, char *argv[] )
{
	bsp_init( argc, argv );

	/* set trace filters */
	RKH_FILTER_ON_GROUP( RKH_TRC_ALL_GROUPS );
	RKH_FILTER_ON_EVENT( RKH_TRC_ALL_EVENTS );

	rkh_trc_open();
	rkh_init();

	rkh_sma_activate( my, qsto, QSTO_SIZE, ( void * )0, 0 );
	rkh_enter();

	rkh_trc_close();
	return 0;
}
\endcode

\n
\ref representing "< Representing the state machine"\n
\ref Usage "> Representing a state machine: step by step"\n\n
*/
