/**
\page preparing Preparing the application files

The sample code for the example presented above port to x86 is located 
in the directory \\demo\\vc08\\. The directory contains the Visual C++ 2008
project files to build the application. See \ref Installation section 
about RKH files. The application files are listed below: 

- \b "rkhcfg.h":	this file adapts and configures RKH. See \ref cfg section. 
					In the \\demo directory there are other \b rkhcfg.h files
					already in existence and it's suggested that these 
					are used as a reference. See the application 
					\subpage rkhcfg_h file. 
					Note that this file is located in the application directory.

- \b "my.c": 		this module implements the "my" state machine, which 
					illustrates all aspects of implementing state machines 
					with RKH framework. Please correlate this implementation 
					with the "my" state diagram in \ref fig1 "Figure 1".
					See the \subpage my_c file.
					Note that this file is located in the application directory.

- \b "myact.c": 	this module declares each of entry, exit, transition, 
					and guard actions to be executed.
					Note that the \b rkhcfg.h file defines the function
					prototype of actions. See \ref cfg section about of 
					available options and \subpage myact_c file.
					Note that this file is located in the application directory.

- \b "my.h": 		this header file contains the definitions of objet 
					structures (state machine, states, and pseudostates) and
					other facilities shared among the components of the
					application. See the \subpage my_h file.
					Note that this file is located in the application directory.

- \b "myact.h":		this header file defines the actions to be executed.
					Note that the \b rkhcfg.h file defines the function
					prototype of actions. See \ref cfg section about of 
					available options and \subpage myact_c file.
					See the \subpage myact_h file.
					Note that this file is located in the application directory.

- \b "myevt.h":		because events are explicitly shared among most of the 
					application components, it's convenient to declare them 
					in the separate header file "myevt.h".
					See the \subpage myevt_h file.
					Note that this file is located in the application directory.

- \b "main.c": 		this file contains the \c main() function along with 
					an example for using the RKH trace facility.
					See the \subpage main_c file.
					Note that this file is located in the application directory.
*/


/**
\page identify Identify and classify states and pseudostates

The \ref fig2 "Figure 2" shows the states and pseudostates from the diagram
presented above, sorted by state nesting level.

\n
\anchor fig2
\image html sttbl.jpg "Figure 2 - State nesting"
*/


/**
\page representing Representing the state machine

Now, this section explains how to implement the "my" state machine 
using the RKH framework, which is shown in \ref fig1 "Figure 1".

- \subpage rep_sm
- \subpage rep_cs
- \subpage rep_bs
- \subpage rep_cjh
- \subpage rep_def
- \subpage rep_act
- \subpage rep_inc

*/

/**
\page basics Basics

As mentioned previously, RKH is a generic, flexible, modular, highly portable, 
ANSI-C compliant, and open-source development tool for implementing 
hierarchical state machines based on modern state machine concepts. This 
modern techniques are used to give an abstract description of the dynamic 
behavior of a system in a substantial manner.

<STRONG> The key features of the RKH framework: </STRONG>

- State machines representation is based on state tables.
- Representing a state machine with RKH is intuitive, and easy.
- Reflects the state diagram without obfuscation.
- The RKH application are highly maintainable.
- Easy to integrate with any event queuing and dispatching mechanism.
- Useful in embedded systems.
- The most of the RKH implementation is \ref Porting "independent of any particular CPU, operating system, or compiler".
- Flexible and \ref cfg "user-configurable code generation".
- Very small footprint.
- Support hierarchically nested states, and flat state machine.
- Support conditional, junction, and history pseudostates.
- Support compound transitions with guards.
- Support local transitions.
- Support mechanism for \link rkh_defer() deferring events\endlink.
- Support \link RKHEVT_T dynamic events\endlink.
- Support a easy way to use \link RKHEVT_T events with arguments\endlink.
- Support systems-friendly \link rkhassert() assertion\endlink macros.
- Support \link RKHEVT_T event dispatching with parameters\endlink.


The RKH not implements neither entire UML specs. nor entire Statechart specs. 
Instead, the RKH intention is to support just enough basic concepts of that 
powerful tools to facilitate the reactive-system modeling holding a solid, 
and efficient implementation. Broadly speaking, the RKH implementation has 
been designed from the ground up to be used in 8-bits platforms but can be 
easily adapted to 16 or 32-bits platforms.

*/


/**
\page rep_sm 1. Instantiating the state machine (and defining the top state)

A state machine is defined with the RKH_CREATE_HSM() macro and declared with
the RKH_DCLR_HSM() macro. Frequently, each state machine is encapsulated
inside a dedicated source file (.c file), from which the RKH_CREATE_HSM() 
macro is used, thus the structure definition is in fact entirely encapsulated 
in its module and is inaccessible to the rest of the application. However, as
a general rule, the state machine must be declared inside a header file 
(.h file) by means of RKH_DCLR_HSM() macro.
In the UML specification, every state machine has a top state 
(the abstract root of every state machine hierarchy), which contains 
all the other elements of the entire state machine. RKH provides the 
top state using the macro RKH_CREATE_HSM(). 

The \ref its "Figure 2" highlights the top state and its relevant aspects. 
Also, shows its implementation using the RKH framework.

\n
\anchor its
\image html its.png "Figure 2 - Top state of state machine \"my\""
\n

<b>Defining the state machine</b>
\n
\code
(1)	//	my.c: state-machine's module

	typedef struct
	{
		rkhuint8 x;
		rkhuint8 y;
(2)	} MYHDATA_T;

	typedef struct
	{
		RKH_T sm;		// base structure
		rkhuint8 x;		// private member
		rkhuint8 y;		// private member
(3)	} MYSM_T;

	static MYHDATA_T mydata;
	...

(4) RKH_CREATE_HSM( 	MYSM_T, 
(5) 					my,
(6) 					0,
(7) 					HCAL,
(8) 					&S1,
(9) 					my_init,
(10) 					&mydata );
\endcode

<b>Declaring the state machine</b>
\n
\code
//	my.h: state-machine's header file

RKH_DCLR_HSM( my );
\endcode

Explanation

\li (1)	Frequently, each state machine is encapsulated inside a dedicated 
		source file (.c file), from which the RKH_CREATE_HSM() macro is used.
\li (2)	In this example, \c MYHDATA_T structure is used like an argc/argv. 
\li (3)	The \c MYSM_T defines the state machine object structure \c my.
		On the other hand, almost every state machine must also store other 
		"extended-state" information. You supply this additional information 
		by means of data members enlisted after the base structure member
		\c sm. Please note that the RKH_T member \c sm is defined as the FIRST 
		member of the derived struct.
		RKH_T is not intended to be instantiated directly, but rather serves 
		as the base structure for derivation of state machines in the 
		application code.
\li (4)	As said before, \c MYSM_T represents the state machine object struture.
\li (5)	\c my is the state machine. Represents the top state of state diagram. 
\li (6)	\c 0 is the state machine descriptor. This number allows to uniquely 
		identify a state machine.
\li (7)	the \c my state machine is defined as a hierarchical state machine. 
		The available property options are enumerated in RKH_HPPTY_T 
		enumeration in the \b rkh.h file.
\li (8)	\c S1 is the initial state.
\li (9)	the \c my_init() function defines the topmost initial transition in 
		the \c my state machine. 
		The function prototype is defined as RKHINIT_T. This argument is 
		(optional), thus it could be declared as NULL. The application code 
		must trigger the initial transition explicitly by invoking 
		rkh_init_hsm() function.
\li (10) \c mydata is used like a argc/argv. This argument is optional, thus 
		it could be declared as NULL or eliminated with RKH_EN_HSM_DATA 
		option. Could be used to pass arguments to the state machine like 
		an argc/argv.
*/


/**
\page rep_cs 2. Instantiating the composite states

A superstate or composite state is defined with the RKH_CREATE_COMP_STATE()
macro and declared with the RKH_DCLR_COMP_STATE() macro. Frequently, each 
state machine and its states (superstates and substates) are encapsulated 
inside a dedicated source file (.c file), from which the 
RKH_CREATE_COMP_STATE() macro is used.

The \ref is1 "Figure 3" highlights the state "S1" and its relevant aspects. 
Also, shows its implementation using the RKH framework.

\n
\anchor is1
\image html is1.png "Figure 3 - composite state \"S1\""

\n
<b>Defining the composite state "S1"</b>
\n
\code
(1)	//	my.c: state-machine's module

(2)	RKH_CREATE_COMP_STATE( 	S1, 
(3)							0, 
(4)							set_y_0, 
(5)							dummy_exit, 
(6)							RKH_ROOT, 
(7)							&S11, 
(8)							&DH );
\endcode

<b>Declaring the composite state "S1"</b>
\n
\code
//	my.h: state-machine's header file

RKH_DCLR_COMP_STATE( S1 );
\endcode

Explanation

\li (1)	Frequently, each state machine and its states are encapsulated 
		inside a dedicated source file (.c file), from which the 
		RKH_CREATE_COMP_STATE() macro is used.
\li (2)	\c S1 is the state name. Represents a composite state structure.
\li (3)	\c 0 is the value of state ID.
\li (4)	\c set_y_0() defines the entry action to be executed unconditionally 
		upon the entry to the \c S1 state. This argument is optional, 
		thus it could be declared as NULL. The RKHENT_T defines the function 
		prototype.
\li (5)	\c dummy_exit() defines the exit action, which is executed upon exit 
		from the \c S1 state. This argument is optional, thus it could be 
		declared as NULL. The RKHEXT_T defines the function prototype.
\li (6)	\c RKH_ROOT is the parent state of \c S1. If a state has no 
		explicit superstate means that it is implicitly nested in 
		the "top" state, and the parent state is defined by means of RKH_ROOT
		macro.  The "top" state is a UML concept that denotes 
		the ultimate root of the state hierarchy in a hierarchical state 
		machine.
\li (7)	\c S11 is the default state of \c S1 state machine. At each level 
		of nesting, a superstate can have a private initial transition that
		designates the active substate after the superstate is entered 
		directly. Here the initial transition of state \c S1 designates the 
		state \c S11 as the initial active substate.
\li (8)	\c DH is the deep history pseudostate. This argument is optional, thus 
		it could be declared as NULL. See RKH_CREATE_SHALLOW_HISTORY_STATE() 
		macro and RKH_CREATE_DEEP_HISTORY_STATE().

In RKH every state is associated with a transition table, which is composed 
of a well-defined set of transitions.
The general syntax of an expression labelling a transition in a statechart is
\e "i[c]/a" where \e i is the input that triggers the transition, \e c is a 
condition that guards the transition from being taken unless it is true when 
\e i occurs, and \e a is an action that is carried out if and when the 
transition is taken. All of these parts are optional. 
Thus, in RKH each row in a table represents a transition, which is 
well-defined by an \e event, a \e guard, an \e action, and \e target state 
(or pseudostate). The \ref is1 "Figure 3" shows the transition table of "S1".

The following figures, \ref is3 "Figure 5", and 
\ref is11 "Figure 6" highlights the composite states "S3", and "S11". 
Also, shows its implementation using the RKH framework.

\n
\anchor is3
\image html is3.png "Figure 5 - composite state \"S3\""

\n
\anchor is11
\image html is11.png "Figure 6 - composite state \"S11\""

\n
*/


/**
\page rep_bs 3. Declaring the basic states

A basic state (also called substate) is defined with the 
RKH_CREATE_BASIC_STATE() macro and declared with the RKH_DCLR_BASIC_STATE() 
macro. Frequently, each state machine and its states (superstates and 
substates) are encapsulated inside a dedicated source file (.c file), from 
which the RKH_CREATE_BASIC_STATE() macro is used.
As will demostrates the use of RKH_CREATE_BASIC_STATE() macro and its
arguments is very similar to RKH_CREATE_COMP_STATE() macro.

The \ref is2 "Figure 7" highlights the basic states "S2". Also, shows its 
implementation using the RKH framework.

\n
\anchor is2
\image html is2.png "Figure 7 - basic state \"S2\""

<b>Defining the basic state "S2"</b>
\n
\code
(1)	//	my.c: state-machine's module

(2)	RKH_CREATE_BASIC_STATE( S2, 
(3)							0, 
(4)							NULL, 
(5)							NULL, 
(6)							RKH_ROOT, 
(7)							NULL );
\endcode

<b>Declaring the basic state "S2"</b>
\n
\code
//	my.h: state-machine's header file

RKH_DCLR_BASIC_STATE( S2 );
\endcode

Explanation

\li (1)	Frequently, each state machine and its states are encapsulated 
		inside a dedicated source file (.c file), from which the 
		RKH_CREATE_BASIC_STATE() macro is used.
\li (2)	\c S2 is the state name. Represents a substate structure.
\li (3)	\c 0 is the value of state ID.
\li (4)	the entry action is unused, therefore it is declared as NULL.
\li (5)	the exit action is unused, therefore it is declared as NULL.
\li (6)	\c RKH_ROOT is the parent state of \c S2. If a state has no 
		explicit superstate means that it is implicitly nested in 
		the "top" state, and the parent state is defined by means of RKH_ROOT
		macro.  The "top" state is a UML concept that denotes 
		the ultimate root of the state hierarchy in a hierarchical state 
		machine.
\li (7)	\c the event preprocessor action is unused, therefore it is 
		declared as NULL. 
		Before sending the arrived event to state machine, it can be 
		previously processed using the event preprocessor function. An 
		action function takes the state 
		machine pointer and the event pointer as arguments. The first 
		parameter is optional in compile-time according to 
		\b RKH_EN_PPRO_HSM_ARG macro.
		Example:
\code
static
RKHE_T
in_keyb( RKHEVT_T *pe )
{
	if( pe->e >= 0 && pe->e <= 9 )
		return DECIMAL;
	if( pe->e == '.' )
		return POINT;
	else
		return pe->e;
}
\endcode

\li (7)	Aditionally, by means of single inheritance in C it could be 
		used as state's abstract data.
		Aditionally, implementing the single inheritance in C is very 
		simply by literally embedding the base type, RKHPPRO_T in 
		this case, as the first member of the derived structure.
		This argument is optional, thus it could be declared as NULL.
		Example:
\code
typedef struct
{
	RKHPPRO_T prepro; 	// extend the RKHPPRO_T class
	unsigned min:4;
	unsigned max:4;
	char *buff;
} SDATA_T;				// this data type will be used in S12 context

static const SDATA_T option = { preprocessor, 4, 8, token };

/* Define S12 state as a substate of S1 */
RKH_CREATE_BASIC_STATE( S12, 5, NULL, NULL, &S1, (RKHPPRO_T*)&option ); 
\endcode

\n
The following figures, \ref is111_s112 "Figure 8", 
\ref is12 "Figure 9", and \ref is31_s32 "Figure 10" highlights the 
basic states "S111", "S112", "S31", "S32", and "S12" respectively. 
Also, shows its implementation using the RKH framework.

\n
\anchor is111_s112
\image html is111_s112.png "Figure 8 - basic states \"S111\", and \"S112\""

\n
\anchor is12
\image html is12.png "Figure 9 - basic state \"S12\""

\n
\anchor is31_s32
\image html is31_s32.png "Figure 10 - basic states \"S31\", and \"S32\""
*/


/**
\page rep_cjh 4. Declaring the pseudostates

The conditional, junction, shallow history, and deep history pseudostates 
are created using RKH_CREATE_COND_STATE(), RKH_CREATE_JUNCTION_STATE(), 
RKH_CREATE_SHALLOW_HISTORY_STATE(), and RKH_CREATE_DEEP_HISTORY_STATE() 
macros respectively, which are defined in \b rkh.h file. Also, these macros
are broadly explained in the \ref qref section. 

The following figures, \ref ic1 "Figure 11", \ref ic2 "Figure 12", 
\ref ij "Figure 13", and \ref ih "Figure 14" highlights the 
pseudostates "C1", "C2", "J", "H", and "DH" respectively. 
Also, shows its implementation using the RKH framework.

\n
\anchor ic1
\image html ic1.png "Figure 11 - conditional pseudostate \"C1\""

\n
\anchor ic2
\image html ic2.png "Figure 12 - conditional pseudostate \"C2\""

A condition connector has one incoming transition and can have several 
outgoing transition segments called branches. Branches are labeled with 
guards that determine which one is to be actually taken. 
Since the condition connector is an OR connector, only one of the branches 
can be taken. Each condition connector can have one special branch with 
a guard labeled rkh_else, which is taken if all the guards on the other 
branches are false. 
Branches cannot contain triggers, but in addition to a guard they may 
contain actions. A branch can enter another condition connector, thus 
providing for the nesting of branches.
In RKH branches are defined by the macro RKH_BRANCH().
The general syntax of an expression labelling a branch in a statechart is
\e "[c]/a" where \e c is a condition that guards the transition from being 
taken unless it is true, and \e a is an action that is carried out if and 
when the transition is taken. All of these parts are optional. 
The following listing shows the C2's branch table:

\code
(1)	RKH_CREATE_BRANCH_TABLE( C2 )
(2)		RKH_BRANCH( x1, 		dummy_act,		&S3		),
		RKH_BRANCH( x2_or_x3, 	NULL,			&S32 	),
(3)		RKH_BRANCH( ELSE, 		NULL,			&S2 	),
(4)	RKH_END_BRANCH_TABLE
\endcode

Explanation

\li (1)	The RKH_CREATE_BRANCH_TABLE() macro creates the "C2"'s 
branch table. Each table type always begins with the macro 
RKH_CREATE_BRANCH_TABLE() and ends with the macro RKH_END_BRANCH_TABLE().
As noted above, sandwiched between these macros are the segment macros 
that actually comprise the condition connector.

\li (2)	The RKH_BRANCH() macro defines a branch segment, where 
\c x1() is the guard function, \c dummy_act() is the action function 
to be taken, and "S3" is the target state.

\li (3)	If all the guards on the other branches are false \c abort function 
will be invoked, and "S2" will be the next state.

\li (4)	The RKH_END_BRANCH_TABLE() macro ends branch table.

As said above, the actions and guards in RKH framework are represented by 
functions.

\n
\anchor ij
\image html ij.png "Figure 13 - junction pseudostate \"J\""

\n
\anchor ih
\image html ih.png "Figure 14 - history pseudostates \"H\" and \"DH\""
*/


/**
\page rep_def 5. Defining the state machine's objects 

The "my.h" header file contains the definitions of objet structures 
(state machine, states, and pseudostates) and other facilities shared among 
the components of the application. See the \subpage my_h file. 
Note that this file is located in the application directory. The following 
listing shows the "my.h" header file, which illustatres some important 
aspects of implementing state machines with RKH.

\code
#ifndef __MY_H__
#define __MY_H__


(1)	#include "rkh.h"


(2)	typedef struct
	{
(3)		RKHEVT_T event;
(4)		rkhuint16 ts;
	} MYEVT_T;


(5)	typedef struct
	{
		rkhuint8 x;
		rkhuint8 y;
	} MYHDATA_T;


/*	Declare the state machine */

(6)	RKH_DCLR_HSM( my );


/*	Defines states and pseudostates. */

(7)	RKH_DCLR_COMP_STATE		S1,S3,S11;
	RKH_DCLR_BASIC_STATE	S2,S31,S32,S111,S112,S12;
	RKH_DCLR_COND_STATE		C1,C2;
	RKH_DCLR_JUNC_STATE		J;
	RKH_DCLR_DHIST_STATE	DH;
	RKH_DCLR_SHIST_STATE	H;


#endif
\endcode

\li (1) RKH interfaces.

\li (2-4) The MYEVT_T structure declares an event with the parameter "ts".
		Such nesting of structures always aligns the data member 
		#RKHEVT_T at the beginning of every instance of the derived 
		structure. In particular, this alignment lets treat a pointer to 
		the derived MYEVT_T structure as a pointer to the #RKHEVT_T 
		base structure. Consequently, can always safely pass a pointer 
		to MYEVT_T to any C function that expects a pointer to #RKHEVT_T.

\li (5) The MYHDATA_T defines the state machine data. 

\li (6) Declares a opaque pointer to previously created state machine to be 
		used as a global object.

\li (7) Defines the states and pseudostates using the corresponding macros
		listed above:
		\n
		\n
		- #RKH_DCLR_COMP_STATE: 	composite state.
		- #RKH_DCLR_BASIC_STATE: 	basic state.
		- #RKH_DCLR_COND_STATE: 	conditional pseudostate.
		- #RKH_DCLR_JUNC_STATE: 	junction pseudostate.
		- #RKH_DCLR_DHIST_STATE: 	deep history pseudostate.
		- #RKH_DCLR_SHIST_STATE: 	shallow history pseudostate.

*/


/**
\page rep_act 6. Declaring the actions

The used actions in the "my" state machine implementation are shown in
\subpage myact_c file.

\n According to "my" state diagram the initial action looks as follow:
\n
\code
void 
my_init( const struct rkh_t *ph )
{
	pd = rkh_get_data( ph );
	pd->x = pd->y = 0;
}
\endcode

\n According to "my" state diagram the transition actions looks as follow:
\n
\code
void
set_y_2( const struct rkh_t *ph, RKHEVT_T *pe )
{
	pd = rkh_get_data( ph );
	pd->y = 2;
	printf( "action: %s()\n", __FUNCTION__ );
	printf( "event.ts = %05d\n", (( MYEVT_T* )pe )->ts );
	printf( "data.x = %02d - data.y = %02d\n", pd->x, pd->y );
}


void
set_y_1( const struct rkh_t *ph, RKHEVT_T *pe )
{
	pd = rkh_get_data( ph );
	pd->y = 1;
	printf( "action: %s()\n", __FUNCTION__ );
	printf( "event.ts = %05d\n", (( MYEVT_T* )pe )->ts );
	printf( "data.x = %02d - data.y = %02d\n", pd->x, pd->y );
}


void
dummy_act( const struct rkh_t *ph, RKHEVT_T *pe )
{
}


void
show_data( const struct rkh_t *ph, RKHEVT_T *pe )
{
	pd = rkh_get_data( ph );
	printf( "data.x = %02d - data.y = %02d\n", pd->x, pd->y );
}
\endcode

\n According to "my" state diagram the entry actions looks as follow:
\n
\code
void
set_x_1( const struct rkh_t *ph )
{
	pd = rkh_get_data( ph );
	pd->x = 1;
}


void
set_x_2( const struct rkh_t *ph )
{
	pd = rkh_get_data( ph );
	pd->x = 2;
}


void
set_x_3( const struct rkh_t *ph )
{
	pd = rkh_get_data( ph );
	pd->x = 3;
}


void
set_y_0( const struct rkh_t *ph )
{
	pd = rkh_get_data( ph );
	pd->y = 0;
}
\endcode

\n According to "my" state diagram the exit actions looks as follow:
\n
\code
void 
dummy_exit( const struct rkh_t *ph )
{
}
\endcode

\n According to "my" state diagram the guards looks as follow:
\n
\code
HUInt
x_equal_1( const struct rkh_t *ph, RKHEVT_T *pe )
{
	pd = rkh_get_data( ph );

	return pd->x == 1 ? RKH_GTRUE : RKH_GFALSE;
}
\endcode

\n According to "my" state diagram the branch selection functions looks 
as follow:
\n
\code
HUInt
y1( const struct rkh_t *ph, RKHEVT_T *pe )
{
	pd = rkh_get_data( ph );
	return pd->y == 1 ? RKH_GTRUE : RKH_GFALSE;
}


HUInt
y2( const struct rkh_t *ph, RKHEVT_T *pe )
{
	pd = rkh_get_data( ph );
	return pd->y == 2 ? RKH_GTRUE : RKH_GFALSE;
}


HUInt
x1( const struct rkh_t *ph, RKHEVT_T *pe )
{
	pd = rkh_get_data( ph );
	return pd->x == 1 ? RKH_GTRUE : RKH_GFALSE;
}


HUInt
x2_or_x3( const struct rkh_t *ph, RKHEVT_T *pe )
{
	pd = rkh_get_data( ph );
	return pd->x == 2 || pd->x == 3 ? RKH_GTRUE : RKH_GFALSE;
}
\endcode

*/


/**
\page rep_inc 7. Include files

The following listing shows a fragment of "my.c" source file, which 
illustatres some aspects of implementing state machines with RKH.

\code
(1) #include "rkh.h"


/*	Includes file of event definitions. */

(2) #include "myevt.h"


/* Includes file of HSM definitions. */

(3) #include "my.h"


/* Includes file of action/guard definitions. */

(4) #include "myact.h"

	...

\endcode

\li (1) Every application C-file that uses RKH must include the \b rkh.h 
		header file. This header file contains the specific adaptation 
		of RKH to the given processor and compiler, also includes the
		RKH interface to implement state machines. The port file is located
		in the application directory.

\li (2) The "myevt.h" header file contains the declarations of triggering 
		events shared among the components of the
		application. This header file is located in the application 
		directory.

\li (3) The "my.h" header file contains the definitions of objet 
		structures (state machine, states, and pseudostates) and
		other facilities shared among the components of the application. 

\li (4) This header file defines the actions to be executed.

*/


/**
\page running Running

<b>Run-to-completation execution model</b>

Event occurrences are detected, dispatched, and then processed by the state 
machine, one at a time. The order of dequeuing is not defined, leaving open 
the possibility of modeling different priority-based schemes.
The semantics of event occurrence processing is based on the 
run-to-completion assumption, interpreted as run-to-completion (RTC) 
processing. Run-to-completion processing means that an event occurrence can 
only be taken from the pool and dispatched if the processing of the previous 
current occurrence is fully completed.

The processing of a single event occurrence by a state machine is known as 
a run-to-completion step. An RTC step is the period of time in which events
are accepted and acted upon. Processing an event always completes within a 
single model step, including exiting the source state, executing any 
associated actions, and entering the target state. Before commencing on a 
run-to-completion step, a state machine is in a stable state configuration 
with all entry/exit/internal activities (but not necessarily state (do) 
activities) completed. The same conditions apply after the run-to-completion 
step is completed. Thus, an event occurrence will never be processed while 
the state machine is in some intermediate and inconsistent situation. 
The run-to-completion step is the passage between two state configurations 
of the state machine. The run-to-completion assumption simplifies the 
transition function of the state machine, since concurrency conflicts are 
avoided during the processing of event, allowing the state machine to 
safely complete its run-to-completion step.

When an event occurrence is detected and dispatched, it may result in one or 
more transitions being enabled for firing. If no transition is enabled and 
the event (type) is not in the deferred event list of the current state 
configuration, the event occurrence is discarded and the run-to-completion 
step is completed.
During a transition, a number of actions may be executed. If such an action 
is a synchronous operation invocation on an object executing a state machine, 
then the transition step is not completed until the invoked object completes 
its run-to-completion step.

<b> IMAGEN </b>

Run-to-completion may be implemented in various ways. The most common way to 
do that is by an event-loop running in its own thread, and that reads 
event occurrences from a pool.

In case of active objects, where each object has its own thread of execution, 
it is very important to clearly distinguish the notion of run-to-completion 
from the concept of thread pre-emption. Namely, run-to-completion event 
handling is performed by a thread that, in principle, can be pre-empted and 
its execution suspended in favor of another thread executing on the same 
processing node. (This is determined by the scheduling policy of the 
underlying thread environment — no assumptions are made about this policy.). 
When the suspended thread is assigned processor time again, it resumes its 
event processing from the point of pre-emption and, eventually, completes 
its event processing.

\note
An active object is an object that, as a direct consequence of its 
creation, commences to execute its behavior, and does not cease until 
either the complete behavior is executed or the object is 
terminated by some external object. (This is sometimes referred to as 
"the object having its own thread of control"). An active object encapsulates 
a thread of control (event loop), a private event queue, and a state machine. 
So, Active object = thread of control + event queue + state machine.

<b>Preemptive Kernel</b>

In the most common and traditional implementations of the active object 
computing model, active objects map to threads of a traditional preemptive 
RTOS or OS. In this standard configuration the active object computing model 
can take full advantage of the underlying RTOS capabilities. In particular, 
if the kernel is preemptive, the active object system achieves exactly the 
same optimal task-level response as traditional tasks.

In this approach, RTC semantics of state machine execution do not mean 
that a state machine has to monopolize the CPU for the duration of the 
RTC step. A preemptive kernel can perform a context switch in the middle of 
the long RTC step to allow a higher-priority active object to run. As long 
as the active objects don't share resources, they can run concurrently and 
complete their RTC steps independently.

<b> IMAGEN </b>

<b>Simple cooperative kernel</b>

The active object computing model can also work with nonpreemptive kernels. 
In fact, one particular cooperative kernel matches the active object 
computing model exceptionally well and can be implemented in an absolutely 
portable manner. A very powerful yet simple solution is exaplained below, the 
simple "vanilla" kernel.

The simple nonpreemptive "vanilla" kernel executes one active object at a 
time in the infinite loop (similar to the "superloop"). 
The "vanilla" kernel is engaged after each event is processed in the 
run-to-completion (RTC) fashion to choose the next highest-priority active 
object ready to process the next event. The "vanilla" scheduler is 
cooperative, which means that all active objects cooperate to share a single
CPU and implicitly yield to each other after every RTC step. The kernel is
nonpreemptive, meaning that every active object must completely process an 
event before any other active object can start processing another event.

The ISRs can preempt the execution of active objects at any time, but due to 
the simplistic nature of the "vanilla" kernel, every ISR returns to exactly 
the preemption point. If the ISR posts an event to any active 
object, the processing of this event won't start until the current RTC step 
completes. The maximum time an event for the highest-priority active object 
can be delayed this way is called the task-level response. With the 
nonpreemptive "vanilla" kernel, the task-level response is equal to the 
longest RTC step of all active objects in the system. Note that the 
task-level response of the "vanilla" kernel is still a lot better than the 
traditional "superloop" (a.k.a. main+ISRs) architecture.

The task-level response of the simple "vanilla" kernel turns out to be 
adequate for surprisingly many applications because state machines by nature 
handle events quickly without a need to busy-wait for events. 
(A state machine simply runs to completion and becomes dormant until another 
event arrives.) Also note that often you can make the task-level response as 
fast as you need by breaking up longer RTC steps into shorter ones.

<b> EXAMPLE </b>

Now consider how the scenario depicted in Figure 6.3(A) plays out under 
the vanilla kernel. The scenario begins with a low-priority active object 
executing its RTC step (dispatch() function) and a high-priority active 
object having its event queue empty. At point (2a) an interrupt preempts 
the low-priority active object. The ISR executes and, among other things, 
posts an event to the high-priority active object (3a).
The interrupt returns and resumes the originally preempted low-priority 
active object (4a).
The low-priority object runs to completion and returns to the main loop. 
At this point, the vanilla scheduler has a chance to run and picks the 
highest-priority nonempty queue, which is the queue of the high-priority 
active object (6a). The vanilla kernel calls the dispatch() function of the 
high-priority active object, which runs to completion.
As you can see, the task-level response of the vanilla kernel is exactly the 
same as any other nonpreemptive kernel. Even so, the vanilla kernel achieves 
this responsiveness without per-task stacks or complex context switching. 
The active objects naturally collaborate to share the CPU and implicitly 
yield to each other at the end of every RTC step. The implementation is 
completely portable and suitable for low-end embedded systems.
The vanilla kernel also permits executing multiple active objects inside a 
single thread of a bigger multitasking system. In this case, the vanilla 
scheduler should efficiently block when all event queues are empty instead 
of wasting CPU cycles for polling the event queues. Posting an event to any 
of the active object queues should unblock the kernel. Of course, this 
requires integrating the vanilla kernel with the underlying multitasking 
system.

Explicar también:
1) Un thread para varias máquinas de estados. 
		Ver book Real-time Concepts ...

The following listing shows the main() function implementation. This function
is included in the \subpage main_c file, which is located in the application 
directory.

\code
	...
	typedef struct
	{
		RKHEVT_T event;
		rkhuint16 ts;
	} MYEVT_T;

	static MYEVT_T mye;
	...

	int
	main( void )
	{
		int c;

(1)		rkh_init_hsm( my );
		srand( ( unsigned )time( NULL ) );

		print_banner();
(2)		rkh_trace_open();

(3)		forever
		{
(4)			c = mygetch();
			
			if( c == 'p' )
(5)				rkh_trace_flush();
			else if ( c == ESC )
(6)				break;
			else if ( c == 'r' )
(7)				rkh_init_hsm( my );
			else
			{
(8)				rkh_set_static_event( &mye, kbmap( c ) );
(9)				mye.ts = ( rkhuint16 )rand();
(10)			rkh_engine( my, ( RKHEVT_T* )&mye );
			}
		}

(11)	rkh_trace_close();
	}
\endcode

\li (1) Initialize the "my" state machine. RKH invokes the init action.
\li (2) Initialize and open the RKH debug session.
\li (3) This is the event loop of the RKH framework.
\li (4) Gets key pressed from the standard input.
\li (5) Flushs the trace stream to the desired host.
\li (6) Terminates the program.
\li (7) Reinitialize the state machine.
\li (8) The	event generated by pressing a key on the keyboard is stored 
		in the signal member of MYEVT_T structure.
\li (9)	The	event has associated parameters that convey a random number.
\li (10)	The \c mye event is dispatched to "my" state machine by means of 
		rkh_engine() function. Events with parameters, such as the MYEVT_T, 
		require explicit casting from the generic base structure #RKHEVT_T 
		to the specific derived structure MYEVT_T.
\li (11)	Terminates the program and close debug session.
*/
